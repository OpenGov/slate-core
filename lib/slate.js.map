{"version":3,"file":"slate.js","sources":["../src/utils/key-utils.js","../src/models/data.js","../src/models/document.js","../src/models/inline.js","../src/models/mark.js","../src/models/leaf.js","../src/models/text.js","../src/models/node.js","../src/models/block.js","../src/utils/path-utils.js","../src/models/point.js","../src/models/decoration.js","../src/utils/is-object.js","../src/models/range.js","../src/models/selection.js","../src/models/value.js","../src/operations/apply.js","../src/operations/invert.js","../src/models/operation.js","../src/models/change.js","../src/plugins/commands.js","../src/utils/text-utils.js","../src/commands/at-range.js","../src/commands/by-path.js","../src/commands/on-history.js","../src/commands/on-selection.js","../src/commands/on-value.js","../src/plugins/queries.js","../src/utils/slate-error.js","../src/plugins/schema.js","../src/commands/with-intent.js","../src/plugins/core.js","../src/controllers/editor.js","../src/utils/mixin.js","../src/interfaces/object.js","../src/interfaces/model.js","../src/utils/memoize.js","../src/interfaces/node.js","../src/interfaces/element.js","../src/interfaces/range.js","../src/index.js"],"sourcesContent":["/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record, Set } from 'immutable'\n\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Set } from 'immutable'\n\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `mark` to the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  addMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.add(mark))\n  }\n\n  /**\n   * Add a `set` of marks to the leaf.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Insert a text `string` into the leaf at `offset`.\n   *\n   * @param {Number} offset\n   * @param {String} string\n   * @return {Leaf}\n   */\n\n  insertText(offset, string) {\n    const { text } = this\n    const next = text.slice(0, offset) + string + text.slice(offset)\n    return this.set('text', next)\n  }\n\n  /**\n   * Remove a `mark` from the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { List, Record } from 'immutable'\n\nimport Leaf from './leaf'\nimport Mark from './mark'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    invariant(\n      object.leaves == null,\n      'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.'\n    )\n\n    const { text = '', marks = [], key = KeyUtils.create() } = object\n    const node = new Text({\n      key,\n      text,\n      marks: Mark.createSet(marks),\n    })\n\n    return node\n  }\n\n  /**\n   * Check if `any` is a listÂ of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Add a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.add(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Add a set of `marks`.\n   *\n   * @param {Set<Mark>} marks\n   * @return {Text}\n   */\n\n  addMarks(marks) {\n    marks = Mark.createSet(marks)\n    const node = this.set('marks', this.marks.union(marks))\n    return node\n  }\n\n  /**\n   * Get the leaves for the text node, with `decorations`.\n   *\n   * @param {List<Decoration>} decorations\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations) {\n    const { key, text, marks } = this\n    const leaf = Leaf.create({ text, marks })\n    let leaves = Leaf.createList([leaf])\n\n    // PERF: We can exit early without decorations.\n    if (!decorations || decorations.size === 0) {\n      return leaves\n    }\n\n    // HACK: this shouldn't be necessary, because the loop below should handle\n    // the `0` case without failures. It may already even, not sure.\n    if (text === '') {\n      const decMarks = decorations.map(d => d.mark)\n      const l = Leaf.create({ marks: decMarks })\n      return List([l])\n    }\n\n    decorations.forEach(dec => {\n      const { start, end, mark } = dec\n      const hasStart = start.key === key\n      const hasEnd = end.key === key\n\n      if (hasStart && hasEnd) {\n        const index = hasStart ? start.offset : 0\n        const length = hasEnd ? end.offset - index : text.length - index\n\n        if (length < 1) return\n        if (index >= text.length) return\n\n        if (index !== 0 || length < text.length) {\n          const [before, bundle] = Leaf.splitLeaves(leaves, index)\n          const [middle, after] = Leaf.splitLeaves(bundle, length)\n          leaves = before.concat(middle.map(x => x.addMark(mark)), after)\n          return\n        }\n      }\n\n      leaves = leaves.map(x => x.addMark(mark))\n    })\n\n    if (leaves === this.leaves) return leaves\n    return Leaf.createLeaves(leaves)\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Number} index\n   * @param {String} string\n   * @return {Text}\n   */\n\n  insertText(index, string) {\n    const { text } = this\n    const next = text.slice(0, index) + string + text.slice(index)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Remove a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.remove(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Remove text from the text node at `index` for `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(index, length) {\n    const { text } = this\n    const next = text.slice(0, index) + text.slice(index + length)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Set a `newProperties` on an existing `mark`.\n   *\n   * @param {Object} mark\n   * @param {Object} newProperties\n   * @return {Text}\n   */\n\n  setMark(properties, newProperties) {\n    const { marks } = this\n    const mark = Mark.create(properties)\n    const newMark = mark.merge(newProperties)\n    const next = marks.remove(mark).add(newMark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Split the node into two at `index`.\n   *\n   * @param {Number} index\n   * @returns {Array<Text>}\n   */\n\n  splitText(index) {\n    const { text } = this\n    const one = this.set('text', text.slice(0, index))\n    const two = this.set('text', text.slice(index)).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * Merge the node with an `other` text node.\n   *\n   * @param {Text} other\n   * @returns {Text}\n   */\n\n  mergeText(other) {\n    const next = this.text + other.text\n    const node = this.set('text', next)\n    return node\n  }\n}\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Text from './text'\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        warning(\n          false,\n          'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      let array = []\n\n      elements.forEach(el => {\n        if (\n          el &&\n          el.object === 'text' &&\n          el.leaves &&\n          Array.isArray(el.leaves)\n        ) {\n          warning(\n            false,\n            'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.'\n          )\n\n          const texts = Text.createList(el.leaves).toArray()\n          array = array.concat(texts)\n          return\n        }\n\n        const node = Node.create(el)\n        array.push(node)\n      })\n\n      const list = List(array)\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      warning(\n        false,\n        'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return (\n      Block.isBlock(any) ||\n      Document.isDocument(any) ||\n      Inline.isInline(any) ||\n      Text.isText(any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      data: Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import { List } from 'immutable'\n\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  const m = min(path, target)\n\n  for (let i = 0; i < m; i++) {\n    const pv = path.get(i)\n    const tv = target.get(i)\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1\n  }\n\n  // Paths should now be equal, otherwise something is wrong\n  return path.size === target.size ? 0 : null\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\nfunction getAncestors(path) {\n  const ancestors = List().withMutations(list => {\n    for (let i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i))\n    }\n  })\n\n  return ancestors\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isEqual(path, target) {\n  return path.equals(target)\n}\n\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isOlder(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl > tl\n}\n\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false\n  const p = path.butLast()\n  const t = target.butLast()\n  return p.equals(t)\n}\n\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isYounger(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl < tl\n}\n\n/**\n * Lift a `path` to refer to its parent.\n *\n * @param {List} path\n * @return {List}\n */\n\nfunction lift(path) {\n  const parent = path.slice(0, -1)\n  return parent\n}\n\n/**\n * Drop a `path`, returning the path from the first child.\n *\n * @param {List} path\n * @return {List}\n */\n\nfunction drop(path) {\n  const relative = path.slice(1)\n  return relative\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\nfunction transform(path, operation) {\n  const { type, position, path: p } = operation\n\n  if (\n    type === 'add_mark' ||\n    type === 'insert_text' ||\n    type === 'remove_mark' ||\n    type === 'remove_text' ||\n    type === 'set_mark' ||\n    type === 'set_node' ||\n    type === 'set_selection' ||\n    type === 'set_value' ||\n    path.size === 0\n  ) {\n    return List([path])\n  }\n\n  const pIndex = p.size - 1\n  const pEqual = isEqual(p, path)\n  const pYounger = isYounger(p, path)\n  const pAbove = isAbove(p, path)\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex)\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pEqual || pAbove) {\n      path = []\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex)\n      path = increment(path, position, pIndex + 1)\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)]\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex)\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex)\n        path = decrement(path, position, pIndex + 1)\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    const { newPath: np } = operation\n\n    if (isEqual(p, np)) {\n      return List([path])\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size))\n      } else {\n        path = np.concat(path.slice(p.size))\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex)\n      }\n\n      // This is the equivalent logic to insert_node for newPath\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1)\n      }\n    }\n  }\n\n  const paths = Array.isArray(path) ? path : [path]\n  return List(paths)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  getAncestors,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  isEqual,\n  isOlder,\n  isSibling,\n  isYounger,\n  lift,\n  drop,\n  max,\n  min,\n  relate,\n  transform,\n}\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined,\n}\n\n/**\n * Point.\n *\n * @type {Point}\n */\n\nclass Point extends Record(DEFAULTS) {\n  /**\n   * Create a new `Point` with `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Point}\n   */\n\n  static create(attrs = {}) {\n    if (Point.isPoint(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Point.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Point.create\\` only accepts objects or points, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable point properties from `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Point.isPoint(a)) {\n      return {\n        key: a.key,\n        offset: a.offset,\n        path: a.path,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('offset' in a) p.offset = a.offset\n      if ('path' in a) p.path = PathUtils.create(a.path)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('path' in a && !('key' in a)) p.key = null\n      if ('key' in a && !('path' in a)) p.path = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Point.createProperties\\` only accepts objects or points, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Point` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Point}\n   */\n\n  static fromJSON(object) {\n    const { key = null, offset = null, path = null } = object\n\n    const point = new Point({\n      key,\n      offset,\n      path: PathUtils.create(path),\n    })\n\n    return point\n  }\n\n  /**\n   * Check whether all properties of the point are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.key != null && this.offset != null && this.path != null\n  }\n\n  /**\n   * Check whether any property of the point is not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Check whether the point is after another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterPoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset > point.offset) ||\n      PathUtils.compare(this.path, point.path) === 1\n    return is\n  }\n\n  /**\n   * Check whether the point is after a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterRange(range) {\n    if (this.isUnset) return false\n    const is = this.isAfterPoint(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtEndOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtStartOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is before another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforePoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset < point.offset) ||\n      PathUtils.compare(this.path, point.path) === -1\n    return is\n  }\n\n  /**\n   * Check whether the point is before a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforeRange(range) {\n    if (this.isUnset) return false\n    const is = this.isBeforePoint(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is inside a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    if (this.isUnset) return false\n    const is =\n      this.equals(range.start) ||\n      this.equals(range.end) ||\n      (this.isAfterPoint(range.start) && this.isBeforePoint(range.end))\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOfNode(node) {\n    if (this.isUnset) return false\n    const last = node.getLastText()\n    const is = this.key === last.key && this.offset === last.text.length\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOfNode(node) {\n    if (this.isUnset) return false\n\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.offset !== 0) return false\n\n    const first = node.getFirstText()\n    const is = this.key === first.key\n    return is\n  }\n\n  /**\n   * Check whether the point is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isInNode(node) {\n    if (this.isUnset) return false\n    if (node.object === 'text' && node.key === this.key) return true\n    if (node.hasNode(this.key)) return true\n    return false\n  }\n\n  /**\n   * Move the point's offset backward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveBackward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveForward(-n)\n    const point = this.setOffset(this.offset - n)\n    return point\n  }\n\n  /**\n   * Move the point's offset forward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveForward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveBackward(-n)\n    const point = this.setOffset(this.offset + n)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String|Number} path\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  moveTo(path, offset = 0) {\n    let key = this.key\n\n    if (typeof path === 'number') {\n      offset = path\n      path = this.path\n    } else if (typeof path === 'string') {\n      key = path\n      path = key === this.key ? this.path : null\n    } else {\n      key = path.equals(this.path) ? this.key : null\n    }\n\n    const point = this.merge({ key, path, offset })\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToStartOfNode(node) {\n    const first = node.getFirstText()\n    const point = this.moveTo(first.key, 0)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToEndOfNode(node) {\n    const last = node.getLastText()\n    const point = this.moveTo(last.key, last.text.length)\n    return point\n  }\n\n  /**\n   * Normalize the point relative to a `node`, ensuring that its key and path\n   * reference a text node, or that it gets unset.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  normalize(node) {\n    // If both the key and path are null, there's no reference to a node, so\n    // make sure it is entirely unset.\n    if (this.key == null && this.path == null) {\n      return this.setOffset(null)\n    }\n\n    const { key, offset, path } = this\n\n    // PERF: this function gets called a lot.\n    // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n    let target = path && node.getNode(path)\n\n    if (!target) {\n      target = node.getNode(key)\n\n      if (target) {\n        // There is a misalignment of path and key\n        const point = this.merge({\n          path: node.getPath(key),\n        })\n\n        return point\n      }\n    }\n\n    if (!target) {\n      warning(false, \"A point's `path` or `key` invalid and was reset!\")\n\n      const text = node.getFirstText()\n      if (!text) return Point.create()\n\n      const point = this.merge({\n        key: text.key,\n        offset: 0,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target.object !== 'text') {\n      warning(false, 'A point should not reference a non-text node!')\n\n      const text = target.getTextAtOffset(offset)\n      const before = target.getOffset(text.key)\n      const point = this.merge({\n        offset: offset - before,\n        key: text.key,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target && path && key && key !== target.key) {\n      warning(false, \"A point's `key` did not match its `path`!\")\n\n      // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n    }\n\n    let point = this.merge({\n      key: target.key,\n      path: path == null ? node.getPath(target.key) : path,\n      offset: offset == null ? 0 : Math.min(offset, target.text.length),\n    })\n\n    // COMPAT: There is an ambiguity, since a point can exist at the end of a\n    // text node, or at the start of the following one. To eliminate it we\n    // enforce that if there is a following text node, we always move it there.\n    if (point.offset === target.text.length) {\n      const block = node.getClosestBlock(point.path)\n      const next = block.getNextText()\n\n      if (next) {\n        point = point.merge({\n          key: next.key,\n          path: node.getPath(next.key),\n          offset: 0,\n        })\n      }\n    }\n\n    return point\n  }\n\n  /**\n   * Set the point's key to a new `key`.\n   *\n   * @param {String} key\n   * @return {Point}\n   */\n\n  setKey(key) {\n    if (key != null) {\n      key = KeyUtils.create(key)\n    }\n\n    const point = this.set('key', key)\n    return point\n  }\n\n  /**\n   * Set the point's offset to a new `offset`.\n   *\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  setOffset(offset) {\n    const point = this.set('offset', offset)\n    return point\n  }\n\n  /**\n   * Set the point's path to a new `path`.\n   *\n   * @param {List|Array} path\n   * @return {Point}\n   */\n\n  setPath(path) {\n    if (path != null) {\n      path = PathUtils.create(path)\n    }\n\n    const point = this.set('path', path)\n    return point\n  }\n\n  /**\n   * Return a JSON representation of the point.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      offset: this.offset,\n      path: this.path && this.path.toArray(),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.key\n    }\n\n    return object\n  }\n\n  /**\n   * Unset the point.\n   *\n   * @return {Point}\n   */\n\n  unset() {\n    return this.merge({\n      key: null,\n      offset: null,\n      path: null,\n    })\n  }\n}\n\n/**\n * Export.\n *\n * @type {Point}\n */\n\nexport default Point\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  mark: undefined,\n}\n\n/**\n * Decoration.\n *\n * @type {Decoration}\n */\n\nclass Decoration extends Record(DEFAULTS) {\n  /**\n   * Create a new `Decoration` with `attrs`.\n   *\n   * @param {Object|Decoration} attrs\n   * @return {Decoration}\n   */\n\n  static create(attrs = {}) {\n    if (Decoration.isDecoration(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Decoration.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Decoration.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Decoration.create\\` only accepts objects or decorations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n   * @return {List<Decoration>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Decoration.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Decoration.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable decoration properties from `attrs`.\n   *\n   * @param {Object|String|Decoration} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Decoration.isDecoration(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        mark: Mark.create(a.mark),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('mark' in a) p.mark = Mark.create(a.mark)\n      return p\n    }\n\n    throw new Error(\n      `\\`Decoration.createProperties\\` only accepts objects or decorations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Decoration` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Decoration}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, mark } = object\n\n    if (!mark) {\n      throw new Error(\n        `Decorations must be created with a \\`mark\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const decoration = new Decoration({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      mark: Mark.fromJSON(mark),\n    })\n\n    return decoration\n  }\n\n  /**\n   * Set new `properties` on the decoration.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Decoration.createProperties(properties)\n    const { anchor, focus, mark } = properties\n    const props = {}\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    if (mark) {\n      props.mark = Mark.create(mark)\n    }\n\n    const decoration = this.merge(props)\n    return decoration\n  }\n\n  /**\n   * Return a JSON representation of the decoration.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      mark: this.mark.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Decoration}\n */\n\nexport default Decoration\n","/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\nexport const TYPES = {\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Determine whether a `value` is of `type`.\n *\n * @param {string} type\n * @param {any} value\n * @return {boolean}\n */\n\nexport default function isObject(type, value) {\n  return !!(value && value[TYPES[type]])\n}\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Decoration from './decoration'\nimport Point from './point'\nimport Selection from './selection'\nimport isObject from '../utils/is-object'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      if (attrs.object === 'range') {\n        return attrs\n      } else {\n        return Range.fromJSON(Range.createProperties(attrs))\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects, decorations, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    const range = new Range({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return range\n  }\n\n  /**\n   * Check if a `value` is a `Range`, or is range-like.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isRange(value) {\n    return (\n      isObject('range', value) ||\n      Decoration.isDecoration(value) ||\n      Selection.isSelection(value)\n    )\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined,\n}\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nclass Selection extends Record(DEFAULTS) {\n  /**\n   * Create a new `Selection` with `attrs`.\n   *\n   * @param {Object|Selection} attrs\n   * @return {Selection}\n   */\n\n  static create(attrs = {}) {\n    if (Selection.isSelection(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Selection.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Selection.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Selection.create\\` only accepts objects, ranges or selections, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable selection properties from `attrs`.\n   *\n   * @param {Object|String|Selection} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Selection.isSelection(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n      return p\n    }\n\n    throw new Error(\n      `\\`Selection.createProperties\\` only accepts objects, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Selection` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Selection}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, isFocused = false, marks = null } = object\n    const selection = new Selection({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return selection\n  }\n\n  /**\n   * Check whether the selection is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Set the `isFocused` property to a new `value`.\n   *\n   * @param {Boolean} value\n   * @return {Selection}\n   */\n\n  setIsFocused(value) {\n    const selection = this.set('isFocused', value)\n    return selection\n  }\n\n  /**\n   * Set the `marks` property to a new set of `marks`.\n   *\n   * @param {Set} marks\n   * @return {Selection}\n   */\n\n  setMarks(marks) {\n    const selection = this.set('marks', marks)\n    return selection\n  }\n\n  /**\n   * Set new `properties` on the selection.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Selection.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const selection = this.merge(props)\n    return selection\n  }\n\n  /**\n   * Return a JSON representation of the selection.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexport default Selection\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { Record, Set, List } from 'immutable'\n\nimport Mark from './mark'\nimport PathUtils from '../utils/path-utils'\nimport Data from './data'\nimport Decoration from './decoration'\nimport Document from './document'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  decorations: undefined,\n  document: undefined,\n  selection: undefined,\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        data: a.data,\n        decorations: a.decorations,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('decorations' in a)\n        p.decorations = Decoration.createList(a.decorations)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { data = {}, decorations = [], document = {}, selection = {} } = object\n    data = Data.fromJSON(data)\n    document = Document.fromJSON(document)\n    selection = document.createSelection(selection)\n    decorations = List(decorations.map(d => Decoration.fromJSON(d)))\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.moveToStartOfNode(text)\n      selection = document.createSelection(selection)\n    }\n\n    const value = new Value({\n      data,\n      decorations,\n      document,\n      selection,\n    })\n\n    return value\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestBlock(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestBlock(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestInline(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestInline(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return (\n      this.selection.start.key &&\n      this.document.getDescendant(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return (\n      this.selection.end.key &&\n      this.document.getDescendant(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getDescendant(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return (\n      this.selection.focus.key &&\n      this.document.getDescendant(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextText(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousText(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the bottom-most inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.addMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  insertText(path, offset, text) {\n    let value = this\n    let { document } = value\n    let node = document.assertNode(path)\n    document = document.insertText(path, offset, text)\n    node = document.assertNode(path)\n    value = value.set('document', document)\n\n    value = value.mapPoints(point => {\n      if (point.key === node.key && point.offset >= offset) {\n        return point.setOffset(point.offset + text.length)\n      } else {\n        return point\n      }\n    })\n\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchor.key === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchor.offset)\n        }\n\n        if (range.focus.key === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focus.offset)\n        }\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n\n    if (PathUtils.isEqual(path, newPath)) {\n      return value\n    }\n\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n    value = value.mapPoints(point => point.setPath(null))\n    return value\n  }\n\n  /**\n   * Remove `mark` at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object === 'text' ? node : node.getFirstText() || node\n    const last = node.object === 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { start, end } = range\n\n      if (node.hasNode(start.key)) {\n        range = prev\n          ? range.moveStartTo(prev.key, prev.text.length)\n          : next ? range.moveStartTo(next.key, 0) : range.unset()\n      }\n\n      if (node.hasNode(end.key)) {\n        range = prev\n          ? range.moveEndTo(prev.key, prev.text.length)\n          : next ? range.moveEndTo(next.key, 0) : range.unset()\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const { length } = text\n    const start = offset\n    const end = offset + length\n\n    value = value.mapPoints(point => {\n      if (point.key !== node.key) {\n        return point\n      }\n\n      if (point.offset >= end) {\n        return point.setOffset(point.offset - length)\n      }\n\n      if (point.offset > start) {\n        return point.setOffset(start)\n      }\n\n      return point\n    })\n\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the value.\n   *\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setProperties(properties) {\n    let value = this\n    const { document } = value\n    const { data, decorations } = properties\n    const props = {}\n\n    if (data) {\n      props.data = data\n    }\n\n    if (decorations) {\n      props.decorations = decorations.map(d => {\n        return d.isSet ? d : document.resolveDecoration(d)\n      })\n    }\n\n    value = value.merge(props)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    const next = selection.setProperties(properties)\n    selection = document.resolveSelection(next)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { start, end } = range\n\n      // If the start was after the split, move it to the next node.\n      if (node.key === start.key && position <= start.offset) {\n        range = range.moveStartTo(next.key, start.offset - position)\n      }\n\n      // If the end was after the split, move it to the next node.\n      if (node.key === end.key && position <= end.offset) {\n        range = range.moveEndTo(next.key, end.offset - position)\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator) {\n    let value = this\n    const { document, selection, decorations } = value\n\n    let sel = selection.isSet ? iterator(selection) : selection\n    if (!sel) sel = selection.unset()\n    if (sel !== selection) sel = document.createSelection(sel)\n    value = value.set('selection', sel)\n\n    let decs = decorations.map(decoration => {\n      let n = decoration.isSet ? iterator(decoration) : decoration\n      if (n && n !== decoration) n = document.createDecoration(n)\n      return n\n    })\n\n    decs = decs.filter(decoration => !!decoration)\n    value = value.set('decorations', decs)\n    return value\n  }\n\n  mapPoints(iterator) {\n    return this.mapRanges(range => range.updatePoints(iterator))\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        .toArray()\n        .map(d => d.toJSON(options))\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    return object\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get history() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.'\n    )\n  }\n\n  change() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.'\n    )\n  }\n}\n\n/**\n * Export.\n */\n\nexport default Value\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'add_mark': {\n      const { path, mark } = op\n      const next = value.addMark(path, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, mark } = op\n      const next = value.removeMark(path, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, properties, newProperties } = op\n      const next = value.setMark(path, properties, newProperties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, newProperties } = op\n      const next = value.setNode(path, newProperties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n      const next = value.setSelection(newProperties)\n      return next\n    }\n\n    case 'set_value': {\n      const { newProperties } = op\n      const next = value.setProperties(newProperties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'insert_node': {\n      const inverse = op.set('type', 'remove_node')\n      return inverse\n    }\n\n    case 'remove_node': {\n      const inverse = op.set('type', 'insert_node')\n      return inverse\n    }\n\n    case 'move_node': {\n      const { newPath, path } = op\n\n      if (PathUtils.isEqual(newPath, path)) {\n        return op\n      }\n\n      // Get the true path that the moved node ended up at\n      const inversePath = PathUtils.transform(path, op).first()\n\n      // Get the true path we are trying to move back to\n      // We transform the right-sibling of the path\n      // This will end up at the operation.path most of the time\n      // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n      const transformedSibling = PathUtils.transform(\n        PathUtils.increment(path),\n        op\n      ).first()\n\n      const inverse = op\n        .set('path', inversePath)\n        .set('newPath', transformedSibling)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark': {\n      const { properties, newProperties } = op\n      const inverse = op\n        .set('properties', newProperties)\n        .set('newProperties', properties)\n      return inverse\n    }\n\n    case 'insert_text': {\n      const inverse = op.set('type', 'remove_text')\n      return inverse\n    }\n\n    case 'remove_text': {\n      const inverse = op.set('type', 'insert_text')\n      return inverse\n    }\n\n    case 'add_mark': {\n      const inverse = op.set('type', 'remove_mark')\n      return inverse\n    }\n\n    case 'remove_mark': {\n      const inverse = op.set('type', 'add_mark')\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Map } from 'immutable'\n\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Selection from './selection'\nimport Value from './value'\nimport apply from '../operations/apply'\nimport invert from '../operations/invert'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  newProperties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  data: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      // Default `data` to an empty object.\n      if (key === 'data' && v === undefined) {\n        v = {}\n      }\n\n      if (v === undefined) {\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        v = Mark.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_node'\n      ) {\n        v = Node.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        v = Selection.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'data') {\n        v = Map(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Check if `any` is a listÂ of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Apply the operation to a `value`.\n   *\n   * @param {Value} value\n   * @return {Value}\n   */\n\n  apply(value) {\n    const next = apply(value, this)\n    return next\n  }\n\n  /**\n   * Invert the operation.\n   *\n   * @return {Operation}\n   */\n\n  invert() {\n    const inverted = invert(this)\n    return inverted\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      if (\n        key === 'mark' ||\n        key === 'marks' ||\n        key === 'node' ||\n        key === 'path' ||\n        key === 'newPath'\n      ) {\n        value = value.toJSON()\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_node'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJSON()\n        if ('focus' in value) v.focus = value.focus.toJSON()\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        value = v\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key === 'data') {\n        value = value.toJSON()\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n}\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import isPlainObject from 'is-plain-object'\nimport { Record } from 'immutable'\n\nimport Operation from './operation'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  operations: undefined,\n  value: undefined,\n}\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change extends Record(DEFAULTS) {\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object|Change} attrs\n   * @return {Change}\n   */\n\n  static create(attrs = {}) {\n    if (Change.isChange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Change.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Change.create\\` only accepts objects or changes, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Change` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Change}\n   */\n\n  static fromJSON(object) {\n    const { value, operations = [] } = object\n\n    const change = new Change({\n      value: Value.create(value),\n      operations: Operation.createList(operations),\n    })\n\n    return change\n  }\n\n  /**\n   * Return a JSON representation of the change.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      value: this.value.toJSON(options),\n      operations: this.operations.toArray().map(o => o.toJSON(options)),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\nfunction CommandsPlugin(commands = {}) {\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    const { type, args } = command\n    const fn = commands[type]\n    if (!fn) return next()\n    editor.command(fn, ...args)\n  }\n\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const command in commands) {\n      editor.registerCommand(command)\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onCommand,\n    onConstruct,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CommandsPlugin\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n\n  if (document.hasDescendant(start.key)) {\n    range = range.moveToStart()\n  } else {\n    range = range.moveTo(end.key, 0).normalize(document)\n  }\n\n  return range\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.addMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n  const texts = document.getTextsAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.addMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\nCommands.addMarksAtRange = (editor, range, marks) => {\n  marks.forEach(mark => editor.addMarkAtRange(range, mark))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteAtRange = (editor, range) => {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection()\n\n  const { value } = editor\n  const { start, end } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  let endKey = end.key\n  let endOffset = end.offset\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey, editor)\n  let isEndVoid = document.hasVoidParent(endKey, editor)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset === 0 &&\n    endOffset === 0 &&\n    isStartVoid === false &&\n    startKey === startBlock.getFirstText().key &&\n    endKey === endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, editor)\n  }\n\n  editor.withoutNormalizing(() => {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      const startVoid = document.getClosestVoid(startKey, editor)\n      const nextText = document.getNextText(startKey)\n      editor.removeNodeByKey(startVoid.key)\n\n      // If the start and end keys are the same, we're done.\n      if (startKey === endKey) return\n\n      // If there is no next text node, we're done.\n      if (!nextText) return\n\n      // Continue...\n      document = editor.value.document\n      startKey = nextText.key\n      startOffset = 0\n      isStartVoid = document.hasVoidParent(startKey, editor)\n    }\n\n    // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n    while (isEndVoid) {\n      const endVoid = document.getClosestVoid(endKey, editor)\n      const prevText = document.getPreviousText(endKey)\n      editor.removeNodeByKey(endVoid.key)\n\n      // Continue...\n      document = editor.value.document\n      endKey = prevText.key\n      endOffset = prevText.text.length\n      isEndVoid = document.hasVoidParent(endKey, editor)\n    }\n\n    // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key)\n      return\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      const index = startOffset\n      const length = endOffset - startOffset\n      editor.removeTextByKey(startKey, index, length)\n      return\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey)\n      endBlock = document.getClosestBlock(endKey)\n      const startText = document.getNode(startKey)\n      const endText = document.getNode(endKey)\n      const startLength = startText.text.length - startOffset\n      const endLength = endOffset\n\n      const ancestor = document.getCommonAncestor(startKey, endKey)\n      const startChild = ancestor.getFurthestAncestor(startKey)\n      const endChild = ancestor.getFurthestAncestor(endKey)\n\n      const startParent = document.getParent(startBlock.key)\n      const startParentIndex = startParent.nodes.indexOf(startBlock)\n      const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n      let child\n\n      // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n      child = startText\n\n      while (child.key !== startChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const afters = parent.nodes.slice(index + 1)\n\n        afters.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove all of the middle children.\n      const startChildIndex = ancestor.nodes.indexOf(startChild)\n      const endChildIndex = ancestor.nodes.indexOf(endChild)\n      const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n      middles.reverse().forEach(node => {\n        editor.removeNodeByKey(node.key)\n      })\n\n      // Remove the nodes before the end text node in the tree.\n      child = endText\n\n      while (child.key !== endChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const befores = parent.nodes.slice(0, index)\n\n        befores.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove any overlapping text content from the leaf text nodes.\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength)\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset)\n      }\n\n      // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document\n        const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n        // Move the end block to be right after the start block.\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(\n            endBlock.key,\n            startParent.key,\n            startParentIndex + 1\n          )\n        }\n\n        // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key)\n        } else {\n          editor.mergeNodeByKey(endBlock.key)\n        }\n\n        // If nested empty blocks are left over above the end block, remove them.\n        if (lonely) {\n          editor.removeNodeByKey(lonely.key)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, editor)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n  if (\n    document.nodes.size !== 1 &&\n    block &&\n    block.text === '' &&\n    block.nodes.size === 1\n  ) {\n    editor.removeNodeByKey(block.key)\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtStartOfNode(text)) {\n    let prev = document.getPreviousText(text.key)\n    const inline = document.getClosestInline(text.key)\n\n    // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key)\n    }\n\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key, editor)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focus.offset) {\n    range = range.moveFocusBackward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focus.offset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteForwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.key, editor)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  const block = document.getClosestBlock(start.key)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !editor.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    const nextBlock = document.getNextBlock(block.key)\n    editor.removeNodeByKey(block.key)\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock)\n    }\n\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.key)\n\n  if (start.isAtEndOfNode(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key, editor)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focus.offset\n  let traversed = text.text.length - focus.offset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteBackwardAtRange(range, o)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteForwardAtRange(range, startBlock.text.length - o)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.key)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const wordOffset = TextUtils.getWordOffsetForward(text, o)\n  const n = wordOffset === 0 ? 1 : wordOffset\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\nCommands.insertBlockAtRange = (editor, range, block) => {\n  range = deleteExpandedAtRange(editor, range)\n  block = Block.create(block)\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (editor.isVoid(startBlock)) {\n    const extra = start.isAtEndOfNode(startBlock) ? 1 : 0\n    editor.insertNodeByKey(parent.key, index + extra, block)\n  } else if (!startInline && startBlock.text === '') {\n    editor.insertNodeByKey(parent.key, index + 1, block)\n  } else if (start.isAtStartOfNode(startBlock)) {\n    editor.insertNodeByKey(parent.key, index, block)\n  } else if (start.isAtEndOfNode(startBlock)) {\n    editor.insertNodeByKey(parent.key, index + 1, block)\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      const atEnd = start.isAtEndOfNode(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOfNode(siblingText)\n        : range.moveToEndOfNode(siblingText)\n\n      startKey = splitRange.start.key\n      startOffset = splitRange.start.offset\n    }\n\n    editor.withoutNormalizing(() => {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset)\n      editor.insertNodeByKey(parent.key, index + 1, block)\n    })\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\nCommands.insertFragmentAtRange = (editor, range, fragment) => {\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    // If the fragment is empty, there's nothing to do after deleting.\n    if (!fragment.nodes.size) return\n\n    // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be rengerated automatically and we won't have an easy way to\n    // reference them.\n    fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n    // Calculate a few things...\n    const { start } = range\n    const { value } = editor\n    let { document } = value\n    let startText = document.getDescendant(start.key)\n    let startBlock = document.getClosestBlock(startText.key)\n    let startChild = startBlock.getFurthestAncestor(startText.key)\n    const isAtStart = start.isAtStartOfNode(startBlock)\n    const parent = document.getParent(startBlock.key)\n    const index = parent.nodes.indexOf(startBlock)\n    const blocks = fragment.getBlocks()\n    const firstChild = fragment.nodes.first()\n    const lastChild = fragment.nodes.last()\n    const firstBlock = blocks.first()\n    const lastBlock = blocks.last()\n    const insertionNode = findInsertionNode(fragment, document, startBlock.key)\n\n    // If the fragment only contains a void block, use `insertBlock` instead.\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock)\n      return\n    }\n\n    // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n    if (\n      insertionNode === fragment &&\n      (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())\n    ) {\n      fragment.nodes.reverse().forEach(node => {\n        editor.insertBlockAtRange(range, node)\n      })\n      return\n    }\n\n    // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n    if (firstBlock !== lastBlock) {\n      const lonelyParent = insertionNode.getFurthest(\n        firstBlock.key,\n        p => p.nodes.size === 1\n      )\n      const lonelyChild = lonelyParent || firstBlock\n\n      const startIndex = parent.nodes.indexOf(startBlock)\n      const excludingLonelyChild = insertionNode.removeNode(lonelyChild.key)\n\n      excludingLonelyChild.nodes.forEach((node, i) => {\n        const newIndex = startIndex + i + 1\n        editor.insertNodeByKey(parent.key, newIndex, node)\n      })\n    }\n\n    // Check if we need to split the node.\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    // Update our variables with the new value.\n    document = editor.value.document\n    startText = document.getDescendant(start.key)\n    startBlock = document.getClosestBlock(start.key)\n    startChild = startBlock.getFurthestAncestor(startText.key)\n\n    // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n    if (firstBlock !== lastBlock) {\n      const nextChild = isAtStart\n        ? startChild\n        : startBlock.getNextSibling(startChild.key)\n      const nextNodes = nextChild\n        ? startBlock.nodes.skipUntil(n => n.key === nextChild.key)\n        : List()\n      const lastIndex = lastBlock.nodes.size\n\n      nextNodes.forEach((node, i) => {\n        const newIndex = lastIndex + i\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex)\n      })\n    }\n\n    // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n    if (\n      !editor.isVoid(startBlock) &&\n      startBlock.text === '' &&\n      !startBlock.findDescendant(n => editor.isVoid(n))\n    ) {\n      editor.removeNodeByKey(startBlock.key)\n      editor.insertNodeByKey(parent.key, index, firstBlock)\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      const inlineChild = startBlock.getFurthestAncestor(startText.key)\n      const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n      firstBlock.nodes.forEach((inline, i) => {\n        const o = start.offset === 0 ? 0 : 1\n        const newIndex = inlineIndex + i + o\n        editor.insertNodeByKey(startBlock.key, newIndex, inline)\n      })\n    }\n  })\n}\n\nconst findInsertionNode = (fragment, document, startKey) => {\n  const hasSingleNode = object => {\n    if (!object || object.object === 'text') return\n    return object.nodes.size === 1\n  }\n\n  const firstNode = object => object && object.nodes.first()\n  let node = fragment\n\n  if (hasSingleNode(fragment)) {\n    let fragmentInner = firstNode(fragment)\n\n    const matches = documentNode => documentNode.type === fragmentInner.type\n    let documentInner = document.getFurthest(startKey, matches)\n\n    if (documentInner === document.getParent(startKey)) node = fragmentInner\n\n    while (hasSingleNode(fragmentInner) && hasSingleNode(documentInner)) {\n      fragmentInner = firstNode(fragmentInner)\n      documentInner = firstNode(documentInner)\n\n      if (fragmentInner.type === documentInner.type) {\n        node = fragmentInner\n      } else {\n        break\n      }\n    }\n  }\n\n  return node\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\nCommands.insertInlineAtRange = (editor, range, inline) => {\n  inline = Inline.create(inline)\n\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    const { value } = editor\n    const { document } = value\n    const { start } = range\n    const parent = document.getParent(start.key)\n    const startText = document.assertDescendant(start.key)\n    const index = parent.nodes.indexOf(startText)\n\n    if (editor.isVoid(parent)) {\n      return\n    }\n\n    editor.splitNodeByKey(start.key, start.offset)\n    editor.insertNodeByKey(parent.key, index + 1, inline)\n  })\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextAtRange = (editor, range, text, marks) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const offset = start.offset\n  const parent = document.getParent(start.key)\n\n  if (editor.isVoid(parent)) {\n    return\n  }\n\n  editor.insertTextByKey(start.key, offset, text, marks)\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\nCommands.removeMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { start, end } = range\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.removeMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setBlocksAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n\n  const { start, end, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(start.key, editor)\n  const startBlock = document.getClosestBlock(start.key)\n  const endBlock = document.getClosestBlock(end.key)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed === false &&\n    start.offset === 0 &&\n    end.offset === 0 &&\n    isStartVoid === false &&\n    start.key === startBlock.getFirstText().key &&\n    end.key === endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  editor.withoutNormalizing(() => {\n    sets.forEach(block => {\n      editor.setNodeByKey(block.key, properties)\n    })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setInlinesAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const inlines = document.getLeafInlinesAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      editor.setNodeByKey(inline.key, properties)\n    })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitBlockAtRange = (editor, range, height = 1) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start, end } = range\n  let { value } = editor\n  let { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.splitDescendantsByKey(node.key, start.key, start.offset)\n\n    value = editor.value\n    document = value.document\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip()\n      const nextBlock = document.getNextBlock(node.key)\n      range = range.moveAnchorToStartOfNode(nextBlock)\n      range = range.setFocus(range.focus.setPath(null))\n\n      if (start.key === end.key) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset)\n      }\n\n      range = document.resolveRange(range)\n      editor.deleteAtRange(range)\n    }\n  })\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitInlineAtRange = (editor, range, height = Infinity) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start } = range\n  const { value } = editor\n  const { document } = value\n  let node = document.assertDescendant(start.key)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  editor.splitDescendantsByKey(node.key, start.key, start.offset)\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.toggleMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const { value } = editor\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark)\n  } else {\n    editor.addMarkAtRange(range, mark)\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlockAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  let { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object !== 'block') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    wrappers.forEach(block => {\n      const first = block.nodes.first()\n      const last = block.nodes.last()\n      const parent = editor.value.document.getParent(block.key)\n      const index = parent.nodes.indexOf(block)\n\n      const children = block.nodes.filter(child => {\n        return blocks.some(b => child === b || child.hasDescendant(b.key))\n      })\n\n      const firstMatch = children.first()\n      const lastMatch = children.last()\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + i)\n        })\n\n        editor.removeNodeByKey(block.key)\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(n => n === firstMatch).forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      } else if (first === firstMatch) {\n        block.nodes\n          .takeUntil(n => n === lastMatch)\n          .push(lastMatch)\n          .forEach((child, i) => {\n            editor.moveNodeByKey(child.key, parent.key, index + i)\n          })\n      } else {\n        const firstText = firstMatch.getFirstText()\n\n        editor.splitDescendantsByKey(block.key, firstText.key, 0)\n\n        document = editor.value.document\n\n        children.forEach((child, i) => {\n          if (i === 0) {\n            const extra = child\n            child = document.getNextBlock(child.key)\n            editor.removeNodeByKey(extra.key)\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      }\n    })\n  })\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapInlineAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object !== 'inline') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      const parent = editor.value.document.getParent(inline.key)\n      const index = parent.nodes.indexOf(inline)\n\n      inline.nodes.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, parent.key, index + i)\n      })\n\n      editor.removeNodeByKey(inline.key)\n    })\n  })\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockAtRange = (editor, range, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { value } = editor\n  const { document } = value\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 === p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  editor.withoutNormalizing(() => {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block)\n\n    // Move the sibling nodes into the new block node.\n    siblings.forEach((node, i) => {\n      editor.moveNodeByKey(node.key, block.key, i)\n    })\n  })\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInlineAtRange = (editor, range, inline) => {\n  const { value } = editor\n  let { document } = value\n  const { start, end } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(start.key)\n\n    if (!inlineParent) {\n      return\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(start.key)\n  let endBlock = document.getClosestBlock(end.key)\n  const startInline = document.getClosestInline(start.key)\n  const endInline = document.getClosestInline(end.key)\n  let startChild = startBlock.getFurthestAncestor(start.key)\n  let endChild = endBlock.getFurthestAncestor(end.key)\n\n  editor.withoutNormalizing(() => {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset)\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    document = editor.value.document\n    startBlock = document.getDescendant(startBlock.key)\n    endBlock = document.getDescendant(endBlock.key)\n    startChild = startBlock.getFurthestAncestor(start.key)\n    endChild = endBlock.getFurthestAncestor(end.key)\n    const startIndex = startBlock.nodes.indexOf(startChild)\n    const endIndex = endBlock.nodes.indexOf(endChild)\n\n    if (startInline && startInline === endInline) {\n      const texts = startBlock.getTextsAtRange(range).map(text => {\n        if (start.key === text.key && end.key === text.key) {\n          return text\n            .splitText(start.offset)[1]\n            .splitText(end.offset - start.offset)[0]\n            .regenerateKey()\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey()\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey()\n        } else {\n          return text.regenerateKey()\n        }\n      })\n\n      inline = inline.set('nodes', texts)\n      editor.insertInlineAtRange(range, inline)\n    } else if (startBlock === endBlock) {\n      document = editor.value.document\n      startBlock = document.getClosestBlock(start.key)\n      startChild = startBlock.getFurthestAncestor(start.key)\n\n      const startInner = document.getNextSibling(startChild.key)\n      const startInnerIndex = startBlock.nodes.indexOf(startInner)\n      const endInner =\n        start.key === end.key\n          ? startInner\n          : startBlock.getFurthestAncestor(end.key)\n      const inlines = startBlock.nodes\n        .skipUntil(n => n === startInner)\n        .takeUntil(n => n === endInner)\n        .push(endInner)\n\n      const node = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node)\n\n      inlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, node.key, i)\n      })\n    } else {\n      const startInlines = startBlock.nodes.slice(startIndex + 1)\n      const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n      const startNode = inline.regenerateKey()\n      const endNode = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode)\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode)\n\n      startInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, startNode.key, i)\n      })\n\n      endInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, endNode.key, i)\n      })\n\n      blocks.slice(1, -1).forEach(block => {\n        const node = inline.regenerateKey()\n        editor.insertNodeByKey(block.key, 0, node)\n\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, node.key, i)\n        })\n      })\n    }\n  })\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\nCommands.wrapTextAtRange = (editor, range, prefix, suffix = prefix) => {\n  const { start, end } = range\n  const startRange = range.moveToStart()\n  let endRange = range.moveToEnd()\n\n  if (start.key === end.key) {\n    endRange = endRange.moveForward(prefix.length)\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(startRange, prefix)\n    editor.insertTextAtRange(endRange, suffix)\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands.addMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.addMarksByPath(path, offset, length, [mark])\n}\n\nCommands.addMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'add_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n  })\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\nCommands.insertFragmentByPath = (editor, path, index, fragment) => {\n  fragment.nodes.forEach((node, i) => {\n    editor.insertNodeByPath(path, index + i, node)\n  })\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nCommands.insertNodeByPath = (editor, path, index, node) => {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextByPath = (editor, path, offset, text, marks) => {\n  marks = Mark.createSet(marks)\n  const { value } = editor\n  const { decorations, document } = value\n  const node = document.assertNode(path)\n  const { key } = node\n  let updated = false\n\n  const decs = decorations.filter(dec => {\n    const { start, end, mark } = dec\n    const isAtomic = editor.isAtomic(mark)\n    if (!isAtomic) return true\n    if (start.key !== key) return true\n\n    if (start.offset < offset && (end.key !== key || end.offset > offset)) {\n      updated = true\n      return false\n    }\n\n    return true\n  })\n\n  editor.withoutNormalizing(() => {\n    if (updated) {\n      editor.setDecorations(decs)\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path,\n      offset,\n      text,\n    })\n\n    if (marks.size) {\n      editor.addMarksByPath(path, offset, text.length, marks)\n    }\n  })\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.mergeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object === 'text' ? previous.text.length : previous.nodes.size\n\n  editor.applyOperation({\n    type: 'merge_node',\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n}\n\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\nCommands.moveNodeByPath = (editor, path, newParentPath, newIndex) => {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor\n  }\n\n  const newPath = newParentPath.concat(newIndex)\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path,\n    newPath,\n  })\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands.removeMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.removeMarksByPath(path, offset, length, [mark])\n}\n\nCommands.removeMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path,\n        offset,\n        length,\n        mark,\n      })\n    })\n  })\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeAllMarksByPath = (editor, path) => {\n  const { state } = editor\n  const { document } = state\n  const node = document.assertNode(path)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.marks.forEach(mark => {\n      editor.removeMarkByKey(text.key, 0, text.text.length, mark)\n    })\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.applyOperation({\n    type: 'remove_node',\n    path,\n    node,\n  })\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nCommands.removeTextByPath = (editor, path, offset, length) => {\n  const { value } = editor\n  const { document, decorations } = value\n  const node = document.assertNode(path)\n\n  const { text } = node\n  const string = text.slice(offset, offset + length)\n\n  const { key } = node\n  let updated = false\n\n  const decs = decorations.filter(dec => {\n    const { start, end, mark } = dec\n    const isAtomic = editor.isAtomic(mark)\n\n    if (!isAtomic) {\n      return true\n    }\n\n    if (start.key !== key) {\n      return true\n    }\n\n    if (start.offset < offset && (end.key !== key || end.offset > offset)) {\n      updated = true\n      return false\n    }\n\n    return true\n  })\n\n  editor.withoutNormalizing(() => {\n    if (updated) {\n      editor.setDecorations(decs)\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path,\n      offset,\n      text: string,\n    })\n  })\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\nCommands.replaceNodeByPath = (editor, path, newNode) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n\n  editor.withoutNormalizing(() => {\n    editor.removeNodeByPath(path)\n    editor.insertNodeByPath(parentPath, index, newNode)\n  })\n}\n\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.replaceTextByPath = (editor, path, offset, length, text, marks) => {\n  editor.withoutNormalizing(() => {\n    editor.removeTextByPath(path, offset, length)\n    editor.insertTextByPath(path, offset, text, marks)\n  })\n}\n\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\nCommands.setMarkByPath = (\n  editor,\n  path,\n  offset,\n  length,\n  properties,\n  newProperties\n) => {\n  properties = Mark.create(properties)\n  newProperties = Mark.createProperties(newProperties)\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path,\n      properties,\n      newProperties,\n    })\n  })\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\nCommands.setNodeByPath = (editor, path, newProperties) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  newProperties = Node.createProperties(newProperties)\n  const prevProperties = pick(node, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_node',\n    path,\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.setTextByPath = (editor, path, text, marks) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  editor.replaceTextByPath(path, 0, end, text, marks)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nCommands.splitNodeByPath = (editor, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = editor\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  editor.applyOperation({\n    type: 'split_node',\n    path,\n    position,\n    target,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n  })\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\nCommands.splitDescendantsByPath = (editor, path, textPath, textOffset) => {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const text = document.assertNode(textPath)\n  const ancestors = document.getAncestors(textPath)\n  const nodes = ancestors\n    .skipUntil(a => a.key === node.key)\n    .reverse()\n    .unshift(text)\n\n  let previous\n  let index\n\n  editor.withoutNormalizing(() => {\n    nodes.forEach(n => {\n      const prevIndex = index == null ? null : index\n      index = previous ? n.nodes.indexOf(previous) + 1 : textOffset\n      previous = n\n      editor.splitNodeByKey(n.key, index, { target: prevIndex })\n    })\n  })\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapInlineByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapInlineAtRange(range, properties)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapBlockByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapBlockAtRange(range, properties)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  editor.withoutNormalizing(() => {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n      editor.removeNodeByPath(parentPath)\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex)\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n    } else {\n      let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n      editor.splitNodeByPath(parentPath, index)\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1)\n    }\n  })\n}\n\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapChildrenByPath = (editor, path) => {\n  path = PathUtils.create(path)\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const { nodes } = node\n\n  editor.withoutNormalizing(() => {\n    nodes.reverse().forEach((child, i) => {\n      const childIndex = nodes.size - i - 1\n      const childPath = path.push(childIndex)\n      editor.moveNodeByPath(childPath, parentPath, index + 1)\n    })\n\n    editor.removeNodeByPath(path)\n  })\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockByPath = (editor, path, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, block)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\nCommands.wrapInlineByPath = (editor, path, inline) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, inline)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\nCommands.wrapNodeByPath = (editor, path, node) => {\n  node = Node.create(node)\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node)\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node)\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst COMMANDS = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeAllMarks',\n  'removeMark',\n  'removeNode',\n  'removeText',\n  'replaceNode',\n  'replaceText',\n  'setMark',\n  'setNode',\n  'setText',\n  'splitNode',\n  'unwrapBlock',\n  'unwrapChildren',\n  'unwrapInline',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of COMMANDS) {\n  Commands[`${method}ByKey`] = (editor, key, ...args) => {\n    const { value } = editor\n    const { document } = value\n    const path = document.assertPath(key)\n    editor[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nCommands.moveNodeByKey = (editor, key, newKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  editor.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nCommands.splitDescendantsByKey = (editor, key, textKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  editor.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import omit from 'lodash/omit'\nimport { List } from 'immutable'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands.save = (editor, operation) => {\n  const { operations, value } = editor\n  const { data } = value\n  let { save, merge } = editor.tmp\n  if (save === false) return\n\n  let undos = data.get('undos') || List()\n  const lastBatch = undos.last()\n  const lastOperation = lastBatch && lastBatch.last()\n\n  // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true\n    } else {\n      merge = shouldMerge(operation, lastOperation)\n    }\n  }\n\n  // If the `merge` flag is true, add the operation to the last batch.\n  if (merge && lastBatch) {\n    const batch = lastBatch.push(operation)\n    undos = undos.pop()\n    undos = undos.push(batch)\n  } else {\n    // Otherwise, create a new batch with the operation.\n    const batch = List([operation])\n    undos = undos.push(batch)\n  }\n\n  // Constrain the history to 100 entries for memory's sake.\n  if (undos.size > 100) {\n    undos = undos.takeLast(100)\n  }\n\n  // Clear the redos and update the history.\n  editor.withoutSaving(() => {\n    const redos = List()\n    const newData = data.set('undos', undos).set('redos', redos)\n    editor.setData(newData)\n  })\n}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.redo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = redos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the batch of operations.\n      batch.forEach(op => {\n        const { type, properties } = op\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n        if (type === 'set_selection') {\n          op = op.set('properties', omit(properties, 'isFocused'))\n        }\n\n        editor.applyOperation(op)\n      })\n\n      // Shift the next value into the undo stack.\n      redos = redos.pop()\n      undos = undos.push(batch)\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.undo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = undos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the inverse of the previous operations.\n      batch\n        .slice()\n        .reverse()\n        .map(op => op.invert())\n        .forEach(inverse => {\n          const { type, properties } = inverse\n\n          // When the operation mutates the selection, omit its `isFocused` value to\n          // prevent the editor focus from changing during undoing.\n          if (type === 'set_selection') {\n            inverse = inverse.set('properties', omit(properties, 'isFocused'))\n          }\n\n          editor.applyOperation(inverse)\n        })\n\n      // Shift the previous operations into the redo stack.\n      redos = redos.push(batch)\n      undos = undos.pop()\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutMerging = (editor, fn) => {\n  const value = editor.tmp.merge\n  editor.tmp.merge = false\n  fn(editor)\n  editor.tmp.merge = value\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutSaving = (editor, fn) => {\n  const value = editor.tmp.save\n  editor.tmp.save = false\n  fn(editor)\n  editor.tmp.save = value\n}\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type === 'set_selection' && p.type === 'set_selection') ||\n    (o.type === 'insert_text' &&\n      p.type === 'insert_text' &&\n      o.offset === p.offset + p.text.length &&\n      o.path.equals(p.path)) ||\n    (o.type === 'remove_text' &&\n      p.type === 'remove_text' &&\n      o.offset + o.text.length === p.offset &&\n      o.path.equals(p.path))\n\n  return merge\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import { is } from 'immutable'\nimport pick from 'lodash/pick'\n\nimport Selection from '../models/selection'\nimport TextUtils from '../utils/text-utils'\n\nconst Commands = {}\n\nCommands.blur = editor => {\n  editor.select({ isFocused: false })\n}\n\nCommands.deselect = editor => {\n  const range = Selection.create()\n  editor.select(range)\n}\n\nCommands.focus = editor => {\n  editor.select({ isFocused: true })\n}\n\nCommands.flip = editor => {\n  editor.command(proxy, 'flip')\n}\n\nCommands.moveAnchorBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorForward = (editor, ...args) => {\n  editor.command(pointForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorTo = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorTo', ...args)\n}\n\nCommands.moveAnchorToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block')\n}\n\nCommands.moveAnchorToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline')\n}\n\nCommands.moveAnchorToEndOfDocument = editor => {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block')\n}\n\nCommands.moveAnchorToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline')\n}\n\nCommands.moveAnchorToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text')\n}\n\nCommands.moveAnchorToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToEndOfNode', ...args)\n}\n\nCommands.moveAnchorToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block')\n}\n\nCommands.moveAnchorToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline')\n}\n\nCommands.moveAnchorToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text')\n}\n\nCommands.moveAnchorToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text')\n}\n\nCommands.moveAnchorToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block')\n}\n\nCommands.moveAnchorToStartOfDocument = editor => {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block')\n}\n\nCommands.moveAnchorToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text')\n}\n\nCommands.moveAnchorToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToStartOfNode', ...args)\n}\n\nCommands.moveAnchorToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block')\n}\n\nCommands.moveAnchorToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline')\n}\n\nCommands.moveAnchorToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text')\n}\n\nCommands.moveAnchorToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text')\n}\n\nCommands.moveBackward = (editor, ...args) => {\n  editor.moveAnchorBackward(...args).moveFocusBackward(...args)\n}\n\nCommands.moveWordBackward = (editor, ...args) => {\n  editor.moveFocusWordBackward(...args).moveToFocus()\n}\n\nCommands.moveEndBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'end', ...args)\n}\n\nCommands.moveEndWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'end', ...args)\n}\n\nCommands.moveEndForward = (editor, ...args) => {\n  editor.command(pointForward, 'end', ...args)\n}\n\nCommands.moveEndWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'end', ...args)\n}\n\nCommands.moveEndTo = (editor, ...args) => {\n  editor.command(proxy, 'moveEndTo', ...args)\n}\n\nCommands.moveEndToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'block')\n}\n\nCommands.moveEndToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline')\n}\n\nCommands.moveEndToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block')\n}\n\nCommands.moveEndToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline')\n}\n\nCommands.moveEndToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text')\n}\n\nCommands.moveEndToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToEndOfNode', ...args)\n}\n\nCommands.moveEndToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block')\n}\n\nCommands.moveEndToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline')\n}\n\nCommands.moveEndToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text')\n}\n\nCommands.moveEndToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'text')\n}\n\nCommands.moveEndToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'block')\n}\n\nCommands.moveEndToStartOfDocument = editor => {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline')\n}\n\nCommands.moveEndToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block')\n}\n\nCommands.moveEndToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline')\n}\n\nCommands.moveEndToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text')\n}\n\nCommands.moveEndToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToStartOfNode', ...args)\n}\n\nCommands.moveEndToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block')\n}\n\nCommands.moveEndToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline')\n}\n\nCommands.moveEndToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text')\n}\n\nCommands.moveEndToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'text')\n}\n\nCommands.moveFocusBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'focus', ...args)\n}\n\nCommands.moveFocusWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'focus', ...args)\n}\n\nCommands.moveFocusForward = (editor, ...args) => {\n  editor.command(pointForward, 'focus', ...args)\n}\n\nCommands.moveFocusWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'focus', ...args)\n}\n\nCommands.moveFocusTo = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusTo', ...args)\n}\n\nCommands.moveFocusToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block')\n}\n\nCommands.moveFocusToEndOfDocument = editor => {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline')\n}\n\nCommands.moveFocusToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block')\n}\n\nCommands.moveFocusToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline')\n}\n\nCommands.moveFocusToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text')\n}\n\nCommands.moveFocusToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToEndOfNode', ...args)\n}\n\nCommands.moveFocusToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block')\n}\n\nCommands.moveFocusToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline')\n}\n\nCommands.moveFocusToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text')\n}\n\nCommands.moveFocusToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text')\n}\n\nCommands.moveFocusToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block')\n}\n\nCommands.moveFocusToStartOfDocument = editor => {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline')\n}\n\nCommands.moveFocusToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block')\n}\n\nCommands.moveFocusToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline')\n}\n\nCommands.moveFocusToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text')\n}\n\nCommands.moveFocusToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToStartOfNode', ...args)\n}\n\nCommands.moveFocusToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block')\n}\n\nCommands.moveFocusToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline')\n}\n\nCommands.moveFocusToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text')\n}\n\nCommands.moveFocusToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text')\n}\n\nCommands.moveForward = (editor, ...args) => {\n  editor.moveAnchorForward(...args).moveFocusForward(...args)\n}\n\nCommands.moveWordForward = (editor, ...args) => {\n  editor.moveFocusWordForward(...args).moveToFocus(...args)\n}\n\nCommands.moveStartBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'start', ...args)\n}\n\nCommands.moveStartWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'start', ...args)\n}\n\nCommands.moveStartForward = (editor, ...args) => {\n  editor.command(pointForward, 'start', ...args)\n}\n\nCommands.moveStartWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'start', ...args)\n}\n\nCommands.moveStartTo = (editor, ...args) => {\n  editor.command(proxy, 'moveStartTo', ...args)\n}\n\nCommands.moveStartToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'block')\n}\n\nCommands.moveStartToEndOfDocument = editor => {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline')\n}\n\nCommands.moveStartToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block')\n}\n\nCommands.moveStartToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline')\n}\n\nCommands.moveStartToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text')\n}\n\nCommands.moveStartToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToEndOfNode', ...args)\n}\n\nCommands.moveStartToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block')\n}\n\nCommands.moveStartToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline')\n}\n\nCommands.moveStartToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text')\n}\n\nCommands.moveStartToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'text')\n}\n\nCommands.moveStartToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'block')\n}\n\nCommands.moveStartToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline')\n}\n\nCommands.moveStartToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block')\n}\n\nCommands.moveStartToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline')\n}\n\nCommands.moveStartToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text')\n}\n\nCommands.moveStartToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToStartOfNode', ...args)\n}\n\nCommands.moveStartToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block')\n}\n\nCommands.moveStartToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline')\n}\n\nCommands.moveStartToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text')\n}\n\nCommands.moveStartToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'text')\n}\n\nCommands.moveTo = (editor, ...args) => {\n  editor.command(proxy, 'moveTo', ...args)\n}\n\nCommands.moveToAnchor = editor => {\n  editor.command(proxy, 'moveToAnchor')\n}\n\nCommands.moveToEnd = editor => {\n  editor.command(proxy, 'moveToEnd')\n}\n\nCommands.moveToEndOfBlock = editor => {\n  editor.moveEndToEndOfBlock().moveToEnd()\n}\n\nCommands.moveToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveToEndOfInline = editor => {\n  editor.moveEndToEndOfInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextBlock = editor => {\n  editor.moveEndToEndOfNextBlock().moveToEnd()\n}\n\nCommands.moveToEndOfNextInline = editor => {\n  editor.moveEndToEndOfNextInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextText = editor => {\n  editor.moveEndToEndOfNextText().moveToEnd()\n}\n\nCommands.moveToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToEndOfNode', ...args)\n}\n\nCommands.moveToEndOfPreviousBlock = editor => {\n  editor.moveStartToEndOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToEndOfPreviousInline = editor => {\n  editor.moveStartToEndOfPreviousInline().moveToStart()\n}\n\nCommands.moveToEndOfPreviousText = editor => {\n  editor.moveStartToEndOfPreviousText().moveToStart()\n}\n\nCommands.moveToEndOfText = editor => {\n  editor.moveEndToEndOfText().moveToEnd()\n}\n\nCommands.moveToFocus = editor => {\n  editor.command(proxy, 'moveToFocus')\n}\n\nCommands.moveToRangeOfDocument = editor => {\n  editor.moveToRangeOfNode(editor.value.document)\n}\n\nCommands.moveToRangeOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToRangeOfNode', ...args)\n}\n\nCommands.moveToStart = editor => {\n  editor.command(proxy, 'moveToStart')\n}\n\nCommands.moveToStartOfBlock = editor => {\n  editor.moveStartToStartOfBlock().moveToStart()\n}\n\nCommands.moveToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveToStartOfInline = editor => {\n  editor.moveStartToStartOfInline().moveToStart()\n}\n\nCommands.moveToStartOfNextBlock = editor => {\n  editor.moveEndToStartOfNextBlock().moveToEnd()\n}\n\nCommands.moveToStartOfNextInline = editor => {\n  editor.moveEndToStartOfNextInline().moveToEnd()\n}\n\nCommands.moveToStartOfNextText = editor => {\n  editor.moveEndToStartOfNextText().moveToEnd()\n}\n\nCommands.moveToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToStartOfNode', ...args)\n}\n\nCommands.moveToStartOfPreviousBlock = editor => {\n  editor.moveStartToStartOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToStartOfPreviousInline = editor => {\n  editor.moveStartToStartOfPreviousInline().moveToStart()\n}\n\nCommands.moveToStartOfPreviousText = editor => {\n  editor.moveStartToStartOfPreviousText().moveToStart()\n}\n\nCommands.moveToStartOfText = editor => {\n  editor.moveStartToStartOfText().moveToStart()\n}\n\nCommands.select = (editor, properties, options = {}) => {\n  properties = Selection.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = editor\n  const { document, selection } = value\n  const newProperties = {}\n  let next = selection.setProperties(properties)\n  next = document.resolveSelection(next)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      newProperties[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (\n    selection.marks &&\n    !newProperties.marks &&\n    (newProperties.anchor || newProperties.focus)\n  ) {\n    newProperties.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(newProperties).length === 0) {\n    return\n  }\n\n  // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n  const prevProperties = pick(selection.toJSON(), Object.keys(newProperties))\n\n  editor.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: prevProperties,\n      newProperties,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\nCommands.setAnchor = (editor, ...args) => {\n  editor.command(proxy, 'setAnchor', ...args)\n}\n\nCommands.setEnd = (editor, ...args) => {\n  editor.command(proxy, 'setEnd', ...args)\n}\n\nCommands.setFocus = (editor, ...args) => {\n  editor.command(proxy, 'setFocus', ...args)\n}\n\nCommands.setStart = (editor, ...args) => {\n  editor.command(proxy, 'setStart', ...args)\n}\n\nCommands.snapshotSelection = editor => {\n  editor.withoutMerging(() => {\n    editor.select(editor.value.selection, { snapshot: true })\n  })\n}\n\n/**\n * Helpers.\n */\n\nfunction proxy(editor, method, ...args) {\n  const range = editor.value.selection[method](...args)\n  editor.select(range)\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  editor[method](node)\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Side = side.slice(0, 1).toUpperCase() + side.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const getDirectionNode = `get${Side}${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  const target = document[getDirectionNode](node.key)\n  if (!target) return\n  editor[method](target)\n}\n\nfunction pointBackward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointForward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    const range = selection[`move${Point}Backward`](n)\n    editor.select(range)\n    return\n  }\n\n  const previous = document.getPreviousText(p.path)\n  if (!previous) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(previous.key)\n  const isPreviousInVoid =\n    previous && document.hasVoidParent(previous.key, editor)\n  editor[`move${Point}ToEndOfNode`](previous)\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Backward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointForward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointBackward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const text = document.getNode(p.path)\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    const range = selection[`move${Point}Forward`](n)\n    editor.select(range)\n    return\n  }\n\n  const next = document.getNextText(p.path)\n  if (!next) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(next.key)\n  const isNextInVoid = document.hasVoidParent(next.key, editor)\n  editor[`move${Point}ToStartOfNode`](next)\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Forward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetBackward(text, o)\n  editor.command(pointBackward, pointName, n > 0 ? n : 1)\n}\n\nfunction pointWordForward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetForward(text, o)\n  editor.command(pointForward, pointName, n > 0 ? n : 1)\n}\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Value from '../models/value'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands.setData = (editor, data = {}) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ data })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands.setDecorations = (editor, decorations = []) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ decorations })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\nfunction QueriesPlugin(queries = {}) {\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const query in queries) {\n      editor.registerQuery(query)\n    }\n\n    return next()\n  }\n\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onQuery(query, editor, next) {\n    const { type, args } = query\n    const fn = queries[type]\n    if (!fn) return next()\n    const ret = fn(editor, ...args)\n    return ret === undefined ? next() : ret\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onConstruct,\n    onQuery,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default QueriesPlugin\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import SlateError from '../utils/slate-error'\nimport Queries from './queries'\n\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\nfunction SchemaPlugin(schema) {\n  const { rules, document, blocks, inlines, marks } = schema\n  let schemaRules = []\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules)\n  }\n\n  if (document) {\n    schemaRules.push({\n      match: [{ object: 'document' }],\n      ...document,\n    })\n  }\n\n  if (blocks) {\n    for (const key in blocks) {\n      schemaRules.push({\n        match: [{ object: 'block', type: key }],\n        ...blocks[key],\n      })\n    }\n  }\n\n  if (inlines) {\n    for (const key in inlines) {\n      schemaRules.push({\n        match: [{ object: 'inline', type: key }],\n        ...inlines[key],\n      })\n    }\n  }\n\n  if (marks) {\n    for (const key in marks) {\n      schemaRules.push({\n        match: [{ object: 'mark', type: key }],\n        ...marks[key],\n      })\n    }\n  }\n\n  /**\n   * Check if a `mark` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Mark} mark\n   * @return {Boolean}\n   */\n\n  function isAtomic(editor, mark) {\n    const rule = schemaRules.find(\n      r => 'isAtomic' in r && testRules(mark, r.match)\n    )\n\n    return rule && rule.isAtomic\n  }\n\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isVoid(editor, node) {\n    const rule = schemaRules.find(\n      r => 'isVoid' in r && testRules(node, r.match)\n    )\n\n    return rule && rule.isVoid\n  }\n\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n  function normalizeNode(node, editor, next) {\n    const error = validateNode(node, editor, () => {})\n    if (!error) return next()\n\n    return () => {\n      const { rule } = error\n      const { size } = editor.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(editor, error)\n      }\n\n      // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error)\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n  function validateNode(node, editor, next) {\n    const matches = schemaRules.filter(r => testRules(node, r.match))\n    const failure = validateRules(node, matches, schemaRules, { every: true })\n    if (!failure) return next()\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n  const queries = Queries({ isAtomic, isVoid })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{ normalizeNode, validateNode }, queries]\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(editor, error) {\n  const { code, node, child, next, previous, key, mark } = error\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid': {\n      return child.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(child.key)\n    }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid': {\n      return previous.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(previous.key)\n    }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid': {\n      return next.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(next.key)\n    }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid': {\n      return node.object === 'document'\n        ? node.nodes.forEach(n => editor.removeNodeByKey(n.key))\n        : editor.removeNodeByKey(node.key)\n    }\n\n    case 'node_data_invalid': {\n      return node.data.get(key) === undefined && node.object !== 'document'\n        ? editor.removeNodeByKey(node.key)\n        : editor.setNodeByKey(node.key, { data: node.data.delete(key) })\n    }\n\n    case 'node_mark_invalid': {\n      return node\n        .getTexts()\n        .forEach(t => editor.removeMarkByKey(t.key, 0, t.text.length, mark))\n    }\n\n    default: {\n      return editor.removeNodeByKey(node.key)\n    }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  const error = validateRules(object, rules)\n  return !error\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules, options = {}) {\n  const { every = false, match = null } = options\n\n  if (typeof rule === 'function') {\n    const valid = rule(object, match)\n    return valid ? null : fail('node_invalid', { rule, node: object })\n  }\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(object, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(object, rule) ||\n    validateType(object, rule) ||\n    validateData(object, rule) ||\n    validateMarks(object, rule) ||\n    validateText(object, rule) ||\n    validateFirst(object, rule) ||\n    validateLast(object, rule) ||\n    validateNodes(object, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  if (typeof rule.object === 'function' && rule.object(node.object)) return\n  return fail('node_object_invalid', { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  if (typeof rule.type === 'function' && rule.type(node.type)) return\n  return fail('node_type_invalid', { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return\n    return fail('node_data_invalid', { rule, node })\n  }\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail('node_data_invalid', { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n\n  const marks =\n    node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(\n      def =>\n        typeof def.type === 'function'\n          ? def.type(mark.type)\n          : def.type === mark.type\n    )\n    if (valid) continue\n    return fail('node_mark_invalid', { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid =\n    typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text)\n  if (valid) return\n  return fail('node_text_invalid', { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let count = 0\n  let lastCount = 0\n  let min = null\n  let index = -1\n  let def = null\n  let max = null\n  let child = null\n  let previous = null\n  let next = null\n\n  function nextDef() {\n    if (defs.length === 0) return false\n    def = defs.shift()\n    lastCount = count\n    count = 0\n    min = def.min || null\n    max = def.max || null\n    return true\n  }\n\n  function nextChild() {\n    index += 1\n    previous = index ? children.get(index - 1) : null\n    child = children.get(index)\n    next = children.get(index + 1)\n    if (!child) return false\n    lastCount = count\n    count += 1\n    return true\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1\n      count = lastCount\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule, node, child, index })\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind()\n            return fail('child_max_invalid', {\n              rule,\n              node,\n              index,\n              child: children.get(index),\n              count,\n              limit: max,\n            })\n          }\n\n          const lastMin = min\n\n          // If there are more groups after this one then child might actually\n          // be valid.\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1\n              continue\n            }\n\n            // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n            if (validateRules(child, def.match) == null) {\n              rewind()\n              return fail('child_min_invalid', {\n                rule,\n                node,\n                index,\n                count: lastCount - 1,\n                limit: lastMin,\n              })\n            }\n\n            // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n            error.rule = rule\n            error.node = node\n            error.child = child\n            error.index = index\n            error.code = error.code.replace('node_', 'child_')\n            return error\n          }\n\n          // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n          if (max != null && count > max) {\n            return fail('child_unknown', { rule, node, child, index })\n          }\n\n          // ... or it's an invalid child for the last group.\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule,\n      node,\n      index: index - 1,\n      count,\n      child: children.get(index - 1),\n      limit: max,\n    })\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule,\n          node,\n          index,\n          count,\n          limit: min,\n        })\n      }\n    } while (nextDef())\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next, [], { match: child })\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default SchemaPlugin\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\nfunction deleteExpanded(editor) {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  }\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.addMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\nCommands.addMarks = (editor, marks) => {\n  marks.forEach(mark => editor.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\nCommands.delete = editor => {\n  const { value } = editor\n  const { selection } = value\n  editor.deleteAtRange(selection)\n\n  // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n  editor.moveToFocus()\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteBackwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteForward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteForwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordForwardAtRange(selection)\n  }\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\nCommands.insertBlock = (editor, block) => {\n  deleteExpanded(editor)\n\n  block = Block.create(block)\n  const { value } = editor\n  const { selection } = value\n  editor.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(block.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\nCommands.insertFragment = (editor, fragment) => {\n  if (!fragment.nodes.size) return\n\n  deleteExpanded(editor)\n\n  let { value } = editor\n  let { document, selection } = value\n  const { start, end } = selection\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const lastBlock = fragment.getClosestBlock(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    (start.isAtStartOfNode(startText) || end.isAtStartOfNode(startText)) ||\n    (start.isAtEndOfNode(endText) || end.isAtEndOfNode(endText))\n\n  const isInserting =\n    firstChild.hasBlockChildren() || lastChild.hasBlockChildren()\n\n  editor.insertFragmentAtRange(selection, fragment)\n  value = editor.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    editor.moveToEndOfNode(newText)\n  } else if (newText) {\n    editor.moveToStartOfNode(newText).moveForward(lastBlock.text.length)\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\nCommands.insertInline = (editor, inline) => {\n  deleteExpanded(editor)\n\n  inline = Inline.create(inline)\n  const { value } = editor\n  const { selection } = value\n  editor.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(inline.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertText = (editor, text, marks) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(selection, text, marks)\n\n    // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({ marks: null })\n    }\n  })\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.removeMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nCommands.replaceMark = (editor, oldMark, newMark) => {\n  editor.removeMark(oldMark)\n  editor.addMark(newMark)\n}\n\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setBlocks = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setBlocksAtRange(selection, properties)\n}\n\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setInlines = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setInlinesAtRange(selection, properties)\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\nCommands.splitBlock = (editor, depth = 1) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  editor.splitBlockAtRange(selection, depth).moveToEnd()\n\n  if (marks && marks.size !== 0) {\n    editor.select({ marks })\n  }\n}\n\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\nCommands.splitInline = (editor, height) => {\n  deleteExpanded(editor)\n  const { value } = editor\n  const { selection } = value\n  editor.splitInlineAtRange(selection, height)\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.toggleMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    editor.removeMark(mark)\n  } else {\n    editor.addMark(mark)\n  }\n}\n\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlock = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapBlockAtRange(selection, properties)\n}\n\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapInline = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapInlineAtRange(selection, properties)\n}\n\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlock = (editor, block) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapBlockAtRange(selection, block)\n}\n\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInline = (editor, inline) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapInlineAtRange(selection, inline)\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\nCommands.wrapText = (editor, prefix, suffix = prefix) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  editor.moveEndBackward(suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import AtRange from '../commands/at-range'\nimport ByPath from '../commands/by-path'\nimport Commands from './commands'\nimport OnHistory from '../commands/on-history'\nimport OnSelection from '../commands/on-selection'\nimport OnValue from '../commands/on-value'\nimport Queries from './queries'\nimport Schema from './schema'\nimport Text from '../models/text'\nimport WithIntent from '../commands/with-intent'\n\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction CorePlugin(options = {}) {\n  const { plugins = [] } = options\n\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  const commands = Commands({\n    ...AtRange,\n    ...ByPath,\n    ...OnHistory,\n    ...OnSelection,\n    ...OnValue,\n    ...WithIntent,\n  })\n\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  const queries = Queries({\n    isAtomic: () => false,\n    isVoid: () => false,\n  })\n\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  const schema = Schema({\n    rules: [\n      // Only allow block nodes in documents.\n      {\n        match: { object: 'document' },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n\n      // Only allow block nodes or inline and text nodes in blocks.\n      {\n        match: {\n          object: 'block',\n          first: { object: 'block' },\n        },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n      {\n        match: {\n          object: 'block',\n          first: [{ object: 'inline' }, { object: 'text' }],\n        },\n        nodes: [\n          {\n            match: [{ object: 'inline' }, { object: 'text' }],\n          },\n        ],\n      },\n\n      // Only allow inline and text nodes in inlines.\n      {\n        match: { object: 'inline' },\n        nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n      },\n\n      // Ensure that block and inline nodes have at least one text child.\n      {\n        match: [{ object: 'block' }, { object: 'inline' }],\n        nodes: [{ min: 1 }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n\n          if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n            editor.insertNodeByKey(node.key, 0, Text.create())\n          }\n        },\n      },\n\n      // Ensure that inline nodes are surrounded by text nodes.\n      {\n        match: { object: 'block' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n      {\n        match: { object: 'inline' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        previous: [{ object: 'block' }, { object: 'text' }],\n        next: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node, index } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else if (code === 'previous_sibling_object_invalid') {\n            i = index\n          } else if (code === 'next_sibling_object_invalid') {\n            i = index + 1\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n\n      // Merge adjacent text nodes with the same marks.\n      {\n        match: { object: 'text' },\n        next: (next, match) => {\n          return next.object !== 'text' || !match.marks.equals(next.marks)\n        },\n        normalize: (editor, error) => {\n          const { code, next } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.mergeNodeByKey(next.key)\n          }\n        },\n      },\n\n      // Remove extra adjacent empty text nodes.\n      {\n        match: { object: 'text' },\n        previous: prev => {\n          return prev.object !== 'text' || prev.text !== ''\n        },\n        next: next => {\n          return next.object !== 'text' || next.text !== ''\n        },\n        normalize: (editor, error) => {\n          const { code, next, previous } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.removeNodeByKey(next.key)\n          } else if (code === 'previous_sibling_invalid') {\n            editor.removeNodeByKey(previous.key)\n          }\n        },\n      },\n    ],\n  })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema, ...plugins, commands, queries]\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CorePlugin\n","import Debug from 'debug'\nimport invariant from 'tiny-invariant'\nimport isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport CommandsPlugin from '../plugins/commands'\nimport CorePlugin from '../plugins/core'\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\nimport QueriesPlugin from '../plugins/queries'\nimport SchemaPlugin from '../plugins/schema'\nimport Value from '../models/value'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nclass Editor {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n\n  constructor(attrs = {}, options = {}) {\n    const { controller = this, construct = true } = options\n    const {\n      onChange = () => {},\n      plugins = [],\n      readOnly = false,\n      value = Value.create(),\n    } = attrs\n\n    this.controller = controller\n    this.middleware = {}\n    this.onChange = onChange\n    this.operations = List()\n    this.readOnly = null\n    this.value = null\n\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true,\n    }\n\n    const core = CorePlugin({ plugins })\n    registerPlugin(this, core)\n\n    if (construct) {\n      this.run('onConstruct')\n      this.setReadOnly(readOnly)\n      this.setValue(value, options)\n    }\n  }\n\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n  applyOperation(operation) {\n    const { operations, controller } = this\n    let value = this.value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Save the operation into the history. Since `save` is a command, we need\n    // to do it without normalizing, since it would have side effects.\n    this.withoutNormalizing(() => {\n      controller.save(operation)\n      value = this.value\n    })\n\n    // Apply the operation to the value.\n    debug('apply', { operation })\n    this.value = operation.apply(value)\n    this.operations = operations.push(operation)\n\n    // Get the paths of the affected nodes, and mark them as dirty.\n    const newDirtyPaths = getDirtyPaths(operation)\n    const dirty = this.tmp.dirty.map(path => {\n      path = PathUtils.create(path)\n      const transformed = PathUtils.transform(path, operation)\n      return transformed.toArray()\n    })\n\n    this.tmp.dirty = Array.prototype.concat.apply(newDirtyPaths, dirty)\n\n    // If we're not already, queue the flushing process on the next tick.\n    if (!this.tmp.flushing) {\n      this.tmp.flushing = true\n      Promise.resolve().then(() => this.flush())\n    }\n\n    return controller\n  }\n\n  /**\n   * Flush the editor's current change.\n   *\n   * @return {Editor}\n   */\n\n  flush() {\n    this.run('onChange')\n    const { value, operations, controller } = this\n    const change = { value, operations }\n    this.operations = List()\n    this.tmp.flushing = false\n    this.onChange(change)\n    return controller\n  }\n\n  /**\n   * Trigger a command by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Editor}\n   */\n\n  command(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      type(controller, ...args)\n      normalizeDirtyPaths(this)\n      return controller\n    }\n\n    debug('command', { type, args })\n    const obj = { type, args }\n    this.run('onCommand', obj)\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Checks if a command by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasCommand(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__command\n\n    return has\n  }\n\n  /**\n   * Checks if a query by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasQuery(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__query\n\n    return has\n  }\n\n  /**\n   * Normalize all of the nodes in the document from scratch.\n   *\n   * @return {Editor}\n   */\n\n  normalize() {\n    const { value, controller } = this\n    let { document } = value\n    const table = document.getKeysToPathsTable()\n    const paths = Object.values(table).map(PathUtils.create)\n    this.tmp.dirty = this.tmp.dirty.concat(paths)\n    normalizeDirtyPaths(this)\n\n    const { selection } = value\n    document = value.document\n\n    if (selection.isUnset && document.nodes.size) {\n      controller.moveToStartOfDocument()\n    }\n\n    return controller\n  }\n\n  /**\n   * Ask a query by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  query(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      return type(controller, ...args)\n    }\n\n    debug('query', { type, args })\n    const obj = { type, args }\n    return this.run('onQuery', obj)\n  }\n\n  /**\n   * Register a command `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerCommand(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__command) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` command because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.command(type, ...args)\n    controller[type] = method\n    method.__command = true\n    return controller\n  }\n\n  /**\n   * Register a query `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerQuery(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__query) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` query because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.query(type, ...args)\n    controller[type] = method\n    method.__query = true\n    return controller\n  }\n\n  /**\n   * Run through the middleware stack by `key` with `args`.\n   *\n   * @param {String} key\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  run(key, ...args) {\n    const { controller, middleware } = this\n    const fns = middleware[key] || []\n    let i = 0\n\n    function next(...overrides) {\n      const fn = fns[i++]\n      if (!fn) return\n\n      if (overrides.length) {\n        args = overrides\n      }\n\n      const ret = fn(...args, controller, next)\n      return ret\n    }\n\n    Object.defineProperty(next, 'change', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'onChange', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'props', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'schema', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'stack', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    return next()\n  }\n\n  /**\n   * Set the `readOnly` flag.\n   *\n   * @param {Boolean} readOnly\n   * @return {Editor}\n   */\n\n  setReadOnly(readOnly) {\n    this.readOnly = readOnly\n    return this\n  }\n\n  /**\n   * Set the editor's `value`.\n   *\n   * @param {Value} value\n   * @param {Options} options\n   * @return {Editor}\n   */\n\n  setValue(value, options = {}) {\n    const { normalize = value !== this.value } = options\n    this.value = value\n\n    if (normalize) {\n      this.normalize()\n    }\n\n    return this\n  }\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, deferring\n   * normalization until after the function has finished executing.\n   *\n   * @param {Function} fn\n   * @return {Editor}\n   */\n\n  withoutNormalizing(fn) {\n    const { controller } = this\n    const value = this.tmp.normalize\n    this.tmp.normalize = false\n    fn(controller)\n    this.tmp.normalize = value\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    warning(\n      false,\n      \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\"\n    )\n\n    return this.controller\n  }\n\n  change(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`'\n    )\n\n    fn(this.controller, ...args)\n  }\n\n  call(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.'\n    )\n\n    fn(this.controller, ...args)\n    return this.controller\n  }\n\n  applyOperations(operations) {\n    warning(\n      false,\n      'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.'\n    )\n\n    operations.forEach(op => this.applyOperation(op))\n    return this.controller\n  }\n\n  setOperationFlag(key, value) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.'\n    )\n\n    this.tmp[key] = value\n    return this\n  }\n\n  getFlag(key, options = {}) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.getFlag` method has been deprecated.'\n    )\n\n    return options[key] !== undefined ? options[key] : this.tmp[key]\n  }\n\n  unsetOperationFlag(key) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.'\n    )\n\n    delete this.tmp[key]\n    return this\n  }\n\n  withoutNormalization(fn) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.'\n    )\n\n    return this.withoutNormalizing(fn)\n  }\n}\n\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\nfunction getDirtyPaths(operation) {\n  const { type, node, path, newPath } = operation\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path]\n    }\n\n    case 'insert_node': {\n      const table = node.getKeysToPathsTable()\n      const paths = Object.values(table).map(p => path.concat(p))\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path, ...paths]\n    }\n\n    case 'split_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const nextPath = PathUtils.increment(path)\n      return [...ancestors, path, nextPath]\n    }\n\n    case 'merge_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const previousPath = PathUtils.decrement(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      if (PathUtils.isEqual(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors = PathUtils.getAncestors(path).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      const newAncestors = PathUtils.getAncestors(newPath).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    while (editor.tmp.dirty.length) {\n      const path = editor.tmp.dirty.pop()\n      normalizeNodeByPath(editor, path)\n    }\n  })\n}\n\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nfunction normalizeNodeByPath(editor, path) {\n  const { controller } = editor\n  let { value } = editor\n  let { document } = value\n  let node = document.assertNode(path)\n  let iterations = 0\n  const max = 100 + (node.object === 'text' ? 1 : node.nodes.size)\n\n  while (node) {\n    const fn = node.normalize(controller)\n\n    if (!fn) {\n      break\n    }\n\n    // Run the normalize `fn` to fix the node.\n    fn(controller)\n\n    // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n    value = editor.value\n    document = value.document\n    const { key } = node\n    let found = document.getDescendant(path)\n\n    if (found && found.key === key) {\n      node = found\n    } else {\n      found = document.getDescendant(key)\n\n      if (found) {\n        node = found\n        path = document.getPath(key)\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break\n      }\n    }\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n  }\n}\n\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array} plugin\n */\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(p => registerPlugin(editor, p))\n    return\n  }\n\n  const { commands, queries, schema, ...rest } = plugin\n\n  if (commands) {\n    const commandsPlugin = CommandsPlugin(commands)\n    registerPlugin(editor, commandsPlugin)\n  }\n\n  if (queries) {\n    const queriesPlugin = QueriesPlugin(queries)\n    registerPlugin(editor, queriesPlugin)\n  }\n\n  if (schema) {\n    const schemaPlugin = SchemaPlugin(schema)\n    registerPlugin(editor, schemaPlugin)\n  }\n\n  for (const key in rest) {\n    const fn = rest[key]\n    const middleware = (editor.middleware[key] = editor.middleware[key] || [])\n    middleware.push(fn)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Editor}\n */\n\nexport default Editor\n","/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\nexport default function mixin(Interface, Classes) {\n  for (const Class of Classes) {\n    // Copy static properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface)) {\n      if (Class.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface, name)\n      Object.defineProperty(Class, name, desc)\n    }\n\n    // Copy instance properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface.prototype)) {\n      if (Class.prototype.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface.prototype, name)\n      Object.defineProperty(Class.prototype, name, desc)\n    }\n  }\n}\n","import Block from '../models/block'\nimport Change from '../models/change'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Editor from '../controllers/editor'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\nimport isObject, { TYPES } from '../utils/is-object'\nimport mixin from '../utils/mixin'\n\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\nfunction create(type) {\n  const TYPE = TYPES[type]\n  const camel = `${type.charAt(0).toUpperCase()}${type.slice(1)}`\n  const is = `is${camel}`\n\n  class ObjectInterface {\n    /**\n     * Return the type of the object.\n     *\n     * @return {String}\n     */\n\n    get object() {\n      return type\n    }\n  }\n\n  ObjectInterface[is] = isObject.bind(null, type)\n  ObjectInterface.prototype[TYPE] = true\n  return ObjectInterface\n}\n\n/**\n * Mix in the object interfaces.\n */\n\nObject.entries({\n  Block,\n  Change,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n}).forEach(([camel, obj]) => mixin(create(camel.toLowerCase()), [obj]))\n","import mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nclass ModelInterface {\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS(...args) {\n    return this.fromJSON(...args)\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(...args) {\n    return this.toJSON(...args)\n  }\n}\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(ModelInterface, [\n  Block,\n  Decoration,\n  Document,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n])\n","/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nconst LEAF = Symbol('LEAF')\n\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nconst STORE_KEY = Symbol('STORE_KEY')\n\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nconst UNDEFINED = Symbol('undefined')\nconst NULL = Symbol('null')\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nlet memoizeStore = new WeakMap()\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {},\n        })\n      }\n\n      const { noArgs, hasArgs } = memoizeStore.get(this)\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(hasArgs, keys)\n      } else {\n        cachedValue = noArgs[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v)\n      } else {\n        noArgs[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key === 'object') {\n      map = map[STORE_KEY] && map[STORE_KEY].get(key)\n    } else {\n      map = map[key]\n    }\n\n    if (map === UNSET) return UNSET\n  }\n\n  return map[LEAF]\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let child = map\n\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key !== 'object') {\n      if (!child[key]) {\n        child[key] = {}\n      }\n\n      child = child[key]\n      continue\n    }\n\n    if (!child[STORE_KEY]) {\n      child[STORE_KEY] = new WeakMap()\n    }\n\n    if (!child[STORE_KEY].has(key)) {\n      const newChild = {}\n      child[STORE_KEY].set(key, newChild)\n      child = newChild\n      continue\n    }\n\n    child = child[STORE_KEY].get(key)\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child[LEAF] = value\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap()\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Text from '../models/text'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass NodeInterface {\n  /**\n   * Get the first text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    if (this.nodes) {\n      this.nodes.forEach((node, i) => {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n\n          warning(\n            !(key in ret),\n            `A node with a duplicate key of \"${key}\" was found! Duplicate keys are not allowed, you should use \\`node.regenerateKey\\` before inserting if you are reusing an existing node.`\n          )\n\n          ret[key] = [i, ...path]\n        }\n      })\n    }\n\n    return ret\n  }\n\n  /**\n   * Get the last text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object === 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a node in the tree, or the node itself.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (this.object === 'text' && path.size) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // Handle the case of passing in a path directly, to match other methods.\n    if (List.isList(key)) return key\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the concatenated text string of a node.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    if (this.object === 'text') {\n      return this.text\n    }\n\n    const text = this.nodes.reduce((memo, c) => memo + c.text, '')\n    return text\n  }\n\n  /**\n   * Check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Normalize the text node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Function|Void}\n   */\n\n  normalize(editor) {\n    const normalizer = editor.run('normalizeNode', this)\n    return normalizer\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Validate the node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Error|Void}\n   */\n\n  validate(editor) {\n    const error = editor.run('validateNode', this)\n    return error\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, [\n  'getFirstText',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getText',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text])\n","import direction from 'direction'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { List, OrderedSet, Set, Stack } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Value from '../models/value'\nimport Operation from '../models/operation'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass ElementInterface {\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.addMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create a decoration with `properties` relative to the node.\n   *\n   * @param {Object|Decoration} properties\n   * @return {Decoration}\n   */\n\n  createDecoration(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.resolveDecoration(properties)\n    return decoration\n  }\n\n  /**\n   * Create a point with `properties` relative to the node.\n   *\n   * @param {Object|Point} properties\n   * @return {Range}\n   */\n\n  createPoint(properties) {\n    properties = Point.createProperties(properties)\n    const point = this.resolvePoint(properties)\n    return point\n  }\n\n  /**\n   * Create a range with `properties` relative to the node.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  createRange(properties) {\n    properties = Range.createProperties(properties)\n    const range = this.resolveRange(properties)\n    return range\n  }\n\n  /**\n   * Create a selection with `properties` relative to the node.\n   *\n   * @param {Object|Selection} properties\n   * @return {Selection}\n   */\n\n  createSelection(properties) {\n    properties = Selection.createProperties(properties)\n    const selection = this.resolveSelection(properties)\n    return selection\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find a descendant node by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively find a descendant node and its path by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Null|[Node, List]}\n   */\n\n  findDescendantAndPath(\n    iterator,\n    pathToThisNode = PathUtils.create([]),\n    findLast = false\n  ) {\n    let found\n    let foundPath\n\n    this.forEachDescendantWithPath(\n      (node, path, nodes) => {\n        if (iterator(node, path, nodes)) {\n          found = node\n          foundPath = path\n          return false\n        }\n      },\n      pathToThisNode,\n      findLast\n    )\n\n    return found ? [found, foundPath] : null\n  }\n\n  // Easy helpers to avoid needing to pass findLast boolean\n  findFirstDescendantAndPath(iterator, pathToThisNode) {\n    return this.findDescendantAndPath(iterator, pathToThisNode, false)\n  }\n\n  findLastDescendantAndPath(iterator, pathToThisNode) {\n    return this.findDescendantAndPath(iterator, pathToThisNode, true)\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object !== 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   * Calls iterator with node and path.\n   *\n   * @param {Function} iterator\n   * @param {List} path\n   * @param {Boolean} findLast - whether to iterate in reverse order\n   */\n\n  forEachDescendantWithPath(iterator, path = PathUtils.create([]), findLast) {\n    let nodes = this.nodes\n    let ret\n\n    if (findLast) nodes = nodes.reverse()\n\n    nodes.forEach((child, i) => {\n      const childPath = path.concat(i)\n\n      if (iterator(child, childPath, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object !== 'text') {\n        ret = child.forEachDescendantWithPath(iterator, childPath, findLast)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      const { start } = range\n      return this.getMarksAtPosition(start.path, start.offset).toSet()\n    }\n\n    const { start, end } = range\n    let startPath = start.path\n    let startOffset = start.offset\n    let endPath = end.path\n    let endOffset = end.offset\n    let startText = this.getDescendant(startPath)\n    let endText = this.getDescendant(endPath)\n\n    if (!PathUtils.isEqual(startPath, endPath)) {\n      while (!PathUtils.isEqual(startPath, endPath) && endOffset === 0) {\n        ;[endText, endPath] = this.getPreviousTextAndPath(endPath)\n        endOffset = endText.text.length\n      }\n\n      while (\n        !PathUtils.isEqual(startPath, endPath) &&\n        startOffset === startText.text.length\n      ) {\n        ;[startText, startPath] = this.getNextTextAndPath(startPath)\n        startOffset = 0\n      }\n    }\n\n    if (PathUtils.isEqual(startPath, endPath)) {\n      return startText.marks\n    }\n\n    const startMarks = startText.marks\n\n    // PERF: if start marks is empty we can return early.\n    if (startMarks.size === 0) {\n      return Set()\n    }\n\n    const endMarks = endText.marks\n    let marks = startMarks.intersect(endMarks)\n\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) {\n      return marks\n    }\n\n    ;[startText, startPath] = this.getNextTextAndPath(startPath)\n\n    while (!PathUtils.isEqual(startPath, endPath)) {\n      if (startText.text.length !== 0) {\n        marks = marks.intersect(startText.marks)\n\n        if (marks.size === 0) {\n          return Set()\n        }\n      }\n\n      ;[startText, startPath] = this.getNextTextAndPath(startPath)\n    }\n\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const ancestors = []\n\n    path.forEach((p, i) => {\n      const current = path.slice(0, i)\n      const parent = this.getNode(current)\n      ancestors.push(parent)\n    })\n\n    return List(ancestors)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object !== 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.'\n    )\n\n    return this.getLeafBlocksAtRange(range)\n  }\n\n  /**\n   * Get the bottom-most block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.'\n    )\n\n    return this.getLeafBlocksAtRangeAsArray(range)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object !== 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type === type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n    if (!path || path.size > 1) return null\n    const child = this.nodes.get(path.first())\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches an `iterator`.\n   *\n   * @param {List|String} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const closest = ancestors.findLast((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return closest || null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.'\n    )\n\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const ancestor = ancestors.findLast(a => editor.query('isVoid', a))\n    return ancestor\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n    if (!a || !b) return null\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {List}\n   */\n\n  getDecorations(editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getDecorations` method takes an `editor` instead of a `value`.'\n    )\n\n    const array = editor.run('decorateNode', this)\n    const decorations = Decoration.createList(array)\n    return decorations\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n    if (!path || !path.size) return null\n\n    let node = this\n\n    path.forEach(index => {\n      node = node.getIn(['nodes', index])\n      return !!node\n    })\n\n    return node\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { start, end } = range\n    let node = this\n    let targetPath = end.path\n    let targetPosition = end.offset\n    let mode = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && mode === 'end') {\n        targetPath = start.path\n        targetPosition = start.offset\n        mode = 'start'\n      }\n    }\n\n    const startIndex = start.path.first() + 1\n    const endIndex = end.path.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest parent of a node that matches an `iterator`.\n   *\n   * @param {Path} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors.find((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return furthest || null\n  }\n\n  /**\n   * Get the furthest ancestor of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(path) {\n    path = this.resolvePath(path)\n    if (!path || !path.size) return null\n    const furthest = this.nodes.get(path.first())\n    return furthest\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the furthest ancestor of a node, where all ancestors to that point only have one child.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(path) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {Array<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object === 'text') return\n\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.'\n    )\n\n    return this.getLeafInlinesAtRange(range)\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.'\n    )\n\n    return this.getLeafInlinesAtRangeAsArray(range)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    const array = this.nodes.reduce((inlines, node) => {\n      if (node.object === 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type === type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start } = range\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(start.path, start.offset)\n    }\n\n    const text = this.getDescendant(start.path)\n    const { marks } = text\n    return marks\n  }\n\n  /**\n   * Get the bottom-most block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafBlocksAtRange(range) {\n    const array = this.getLeafBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return List(OrderedSet(array))\n  }\n\n  /**\n   * Get the bottom-most descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array<Node>}\n   */\n\n  getLeafBlocksAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const { start, end } = range\n\n    return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path)\n  }\n\n  /**\n   * Get the bottom-most descendants between two paths as an array\n   *\n   * @param {List|Null} startPath\n   * @param {List|Null} endPath\n   * @return {Array<Node>}\n   */\n\n  getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getClosestBlock(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getBlocksAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object !== 'block') {\n        return\n      } else if (node.isLeafBlock()) {\n        array.push(node)\n      } else {\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getLeafBlocksBetweenPathPositionsAsArray(\n            childStartPath,\n            childEndPath\n          )\n        )\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafInlinesAtRange(range) {\n    const array = this.getLeafInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    const list = List(OrderedSet(array))\n    return list\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array<Node>}\n   */\n\n  getLeafInlinesAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    const result = []\n\n    this.nodes.forEach(node => {\n      result.push(\n        node.object === 'text' ? node.marks.toArray() : node.getMarksAsArray()\n      )\n    })\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {List|string} key\n   * @param {number} offset\n   * @return {Set}\n   */\n\n  getMarksAtPosition(path, offset) {\n    path = this.resolvePath(path)\n    const text = this.getDescendant(path)\n    const currentMarks = text.marks\n\n    if (offset !== 0) {\n      return currentMarks\n    }\n\n    const closestBlock = this.getClosestBlock(path)\n\n    // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n    if (closestBlock.text === '') {\n      return currentMarks\n    }\n\n    const previous = this.getPreviousTextAndPath(path)\n\n    if (!previous) {\n      return Set()\n    }\n\n    const [previousText, previousPath] = previous\n\n    if (closestBlock.hasDescendant(previousPath)) {\n      return previousText.marks\n    }\n\n    return currentMarks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const marks = Set(this.getOrderedMarksAtRange(range))\n    return marks\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object === 'text'\n        ? memo.concat(node.getMarksAsArray().filter(m => m.type === type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get the block node after a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextBlock(path) {\n    path = this.resolvePath(path)\n    const match = this.getNextDeepMatchingNodeAndPath(\n      path,\n      n => n.object === 'block'\n    )\n\n    return match ? match[0] : null\n  }\n\n  /**\n   * Get the next node in the tree from a node.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      const target = PathUtils.increment(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next node in the tree from a node that matches iterator\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List} path\n   * @return {Node|Null}\n   */\n\n  getNextMatchingNodeAndPath(path, iterator = () => true) {\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n\n      let nextPath = PathUtils.increment(p)\n      let nextNode = this.getNode(nextPath)\n\n      while (nextNode && !iterator(nextNode)) {\n        nextPath = PathUtils.increment(nextPath)\n        nextNode = this.getNode(nextPath)\n      }\n\n      if (nextNode) return [nextNode, nextPath]\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next, deepest node in the tree from a node that matches iterator\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getNextDeepMatchingNodeAndPath(path, iterator = () => true) {\n    const match = this.getNextMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [nextNode, nextPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        nextNode.object !== 'text' &&\n        nextNode.findFirstDescendantAndPath(iterator, nextPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[nextNode, nextPath] = childMatch\n    }\n\n    if (!nextNode) return null\n\n    return iterator(nextNode)\n      ? [nextNode, nextPath]\n      : this.getNextDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const p = PathUtils.increment(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const next = this.getNextNode(path)\n    if (!next) return null\n    const text = next.getFirstText()\n    return text\n  }\n\n  getNextTextAndPath(path) {\n    if (!path) return null\n    if (!path.size) return null\n    const match = this.getNextDeepMatchingNodeAndPath(\n      path,\n      n => n.object === 'text'\n    )\n    return match\n  }\n\n  /**\n   * Get all of the nodes in a `range`. This includes all of the\n   * text nodes inside the range and all ancestors of those text\n   * nodes up to this node.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getNodesAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n    const { start, end } = range\n\n    // Do a depth-first stack-based search for all nodes in the range\n    // Nodes that are pushed to the stack are inside the range\n\n    // Start with the nodes that are on the highest level in the tree\n    let stack = Stack(\n      this.nodes\n        .slice(start.path.get(0), end.path.get(0) + 1)\n        .map((node, index) => ({\n          node,\n          onStartEdge: index === 0,\n          onEndEdge: index === end.path.get(0) - start.path.get(0),\n          relativeStartPath: start.path.slice(1),\n          relativeEndPath: end.path.slice(1),\n        }))\n    )\n\n    const result = []\n\n    while (stack.size > 0) {\n      const {\n        node,\n        onStartEdge,\n        onEndEdge,\n        relativeStartPath,\n        relativeEndPath,\n      } = stack.peek()\n\n      stack = stack.shift()\n      result.push(node)\n\n      if (node.object === 'text') continue\n\n      // Modify indexes to exclude children that are outside of the range\n      const startIndex = onStartEdge ? relativeStartPath.get(0) : 0\n      const endIndex = onEndEdge ? relativeEndPath.get(0) : node.nodes.size - 1\n\n      // Push children that are inside the range to the stack\n      stack = stack.pushAll(\n        node.nodes.slice(startIndex, endIndex + 1).map((n, i) => ({\n          node: n,\n          onStartEdge: onStartEdge && i === 0,\n          onEndEdge: onEndEdge && i === endIndex - startIndex,\n          relativeStartPath:\n            onStartEdge && i === 0 ? relativeStartPath.slice(1) : null,\n          relativeEndPath:\n            onEndEdge && i === endIndex - startIndex\n              ? relativeEndPath.slice(1)\n              : null,\n        }))\n      )\n    }\n\n    return List(result)\n  }\n\n  /**\n   * Get the offset for a descendant text node by `path` or `key`.\n   *\n   * @param {List|string} path\n   * @return {Number}\n   */\n\n  getOffset(path) {\n    path = this.resolvePath(path)\n    this.assertDescendant(path)\n\n    // Calculate the offset of the nodes before the highest child.\n    const index = path.first()\n\n    const offset = this.nodes\n      .slice(0, index)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret =\n      path.size === 1\n        ? offset\n        : offset + this.nodes.get(index).getOffset(PathUtils.drop(path))\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { start } = range\n    const offset = this.getOffset(start.path) + start.offset\n    return offset\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start, end } = range\n\n    if (range.isUnset) {\n      return OrderedSet()\n    }\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use path? and offset as proxies for cache\n      return this.getMarksAtPosition(start.path, start.offset)\n    }\n\n    const marks = this.getOrderedMarksBetweenPositions(\n      start.path,\n      start.offset,\n      end.path,\n      end.offset\n    )\n\n    return marks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {List|string} startPath\n   * @param {number} startOffset\n   * @param {List|string} endPath\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n    const startText = this.getDescendant(startPath)\n\n    // PERF: if the paths are equal, we can just use the start.\n    if (PathUtils.isEqual(startPath, endPath)) {\n      return startText.marks\n    }\n\n    const texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        result.union(text.marks)\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Get the block node before a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(path) {\n    path = this.resolvePath(path)\n    const match = this.getPreviousDeepMatchingNodeAndPath(\n      path,\n      n => n.object === 'block'\n    )\n\n    return match ? match[0] : null\n  }\n\n  /**\n   * Get the highest block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getRootBlocksAtRange(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n\n    const { start, end } = range\n\n    return this.nodes.slice(start.path.first(), end.path.first() + 1)\n  }\n\n  /**\n   * Get the top-most inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getRootInlinesAtRange(range) {\n    const array = this.getRootInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    const list = List(OrderedSet(array))\n    return list\n  }\n\n  /**\n   * Get the top-most inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getRootInlinesAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getFurthestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      const target = PathUtils.decrement(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the previous node in the tree from a node that matches iterator\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List} path\n   * @return {Node|Null}\n   */\n\n  getPreviousMatchingNodeAndPath(path, iterator = () => true) {\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      let previousPath = PathUtils.decrement(p)\n      let previousNode = this.getNode(previousPath)\n\n      while (previousNode && !iterator(previousNode)) {\n        previousPath = PathUtils.decrement(previousPath)\n        previousNode = this.getNode(previousPath)\n      }\n\n      if (previousNode) return [previousNode, previousPath]\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next previous in the tree from a node that matches iterator\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   * Once a node is found, the last deepest child matching is returned\n   *\n   * @param {List} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getPreviousDeepMatchingNodeAndPath(path, iterator = () => true) {\n    const match = this.getPreviousMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [previousNode, previousPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        previousNode.object !== 'text' &&\n        previousNode.findLastDescendantAndPath(iterator, previousPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[previousNode, previousPath] = childMatch\n    }\n\n    if (!previousNode) return null\n\n    return iterator(previousNode)\n      ? [previousNode, previousPath]\n      : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    if (path.last() === 0) return null\n    const p = PathUtils.decrement(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node before a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const previous = this.getPreviousNode(path)\n    if (!previous) return null\n    const match = previous.getLastText()\n    return match\n  }\n\n  getPreviousTextAndPath(path) {\n    if (!path) return null\n    if (!path.size) return null\n    const match = this.getPreviousDeepMatchingNodeAndPath(\n      path,\n      n => n.object === 'text'\n    )\n    return match\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = true) {\n    const { start, end } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (start.key === end.key) {\n      const child = this.getFurthestAncestor(start.key)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let startIndex = null\n    let endIndex = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object === 'text') {\n        if (startIndex == null && child.key === start.key) startIndex = i\n        if (endIndex == null && child.key === end.key) endIndex = i + 1\n      } else {\n        if (startIndex == null && child.hasDescendant(start.key)) startIndex = i\n        if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return startIndex == null || endIndex == null\n    })\n\n    if (isSelected && startIndex == null) startIndex = 0\n    if (isSelected && endIndex == null) endIndex = this.nodes.size\n    return startIndex == null ? null : { start: startIndex, end: endIndex }\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n    const text = this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n\n    return text\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object === 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as a List.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    const arr = this.getTextsAtRangeAsArray(range)\n    return List(arr)\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array<Node>}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n    const { start, end } = range\n    const texts = this.getTextsBetweenPathPositionsAsArray(start.path, end.path)\n    return texts\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key / path in arguments for cache\n   *\n   * @param {List|string} startPath\n   * @param {List|string} endPath\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startPath, endPath) {\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n\n    return this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {List|falsey} startPath\n   * @param {List|falsey} endPath\n   * @returns {Array}\n   */\n\n  getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getDescendant(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getTextsAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object === 'text') {\n        array.push(node)\n      } else {\n        // For the node at start and end of this list, we want to provide a start and end path\n        // For other nodes, we can just get all their text nodes, they are between the paths\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath)\n        )\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosestVoid(path, editor)\n    return !!closest\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  insertText(path, offset, text) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.insertText(offset, text)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    const { object, nodes } = this\n    if (object !== 'block') return false\n    if (!nodes.size) return true\n\n    return nodes.first().object !== 'block'\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    const { object, nodes } = this\n    if (object !== 'inline') return false\n    if (!nodes.size) return true\n\n    return nodes.first().object !== 'inline'\n  }\n\n  /**\n   * Check whether a descendant node is inside a range. This will return true for all\n   * text nodes inside the range and all ancestors of those text nodes up to this node.\n   *\n   * @param {List|string} path\n   * @param {Range} range\n   * @return {Node}\n   */\n\n  isNodeInRange(path, range) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    range = this.resolveRange(range)\n    if (range.isUnset) return false\n\n    const toStart = PathUtils.compare(path, range.start.path)\n    const toEnd =\n      range.start.key === range.end.key\n        ? toStart\n        : PathUtils.compare(path, range.end.path)\n\n    const is = toStart !== -1 && toEnd !== 1\n    return is\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n    // Alternative 1: pass the operation through from apply -> value.moveNode\n    // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n    const op = Operation.create({\n      type: 'move_node',\n      path,\n      newPath,\n    })\n    newPath = PathUtils.transform(path, op).first()\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Remove `mark` from text at `path`.\n   *\n   * @param {List} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.removeMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a `decoration`, relative to the node, ensuring that the keys and\n   * offsets in the decoration exist and that they are synced with the paths.\n   *\n   * @param {Decoration|Object} decoration\n   * @return {Decoration}\n   */\n\n  resolveDecoration(decoration) {\n    decoration = Decoration.create(decoration)\n    decoration = decoration.normalize(this)\n    return decoration\n  }\n\n  /**\n   * Resolve a `point`, relative to the node, ensuring that the keys and\n   * offsets in the point exist and that they are synced with the paths.\n   *\n   * @param {Point|Object} point\n   * @return {Point}\n   */\n\n  resolvePoint(point) {\n    point = Point.create(point)\n    point = point.normalize(this)\n    return point\n  }\n\n  /**\n   * Resolve a `range`, relative to the node, ensuring that the keys and\n   * offsets in the range exist and that they are synced with the paths.\n   *\n   * @param {Range|Object} range\n   * @return {Range}\n   */\n\n  resolveRange(range) {\n    range = Range.create(range)\n    range = range.normalize(this)\n    return range\n  }\n\n  /**\n   * Resolve a `selection`, relative to the node, ensuring that the keys and\n   * offsets in the selection exist and that they are synced with the paths.\n   *\n   * @param {Selection|Object} selection\n   * @return {Selection}\n   */\n\n  resolveSelection(selection) {\n    selection = Selection.create(selection)\n    selection = selection.normalize(this)\n    return selection\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, properties, newProperties) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.setMark(properties, newProperties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  ElementInterface.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(ElementInterface.prototype, [\n  'getBlocksAsArray',\n  'getLeafBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesByTypeAsArray',\n  'getLeafBlocksAtRangeAsArray',\n  'getLeafInlinesAtRangeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getNodesAtRange',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getOffset',\n  'getOffsetAtRange',\n  'getPreviousBlock',\n  'getRootBlocksAtRange',\n  'getRootInlinesAtRangeAsArray',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPathPositionsAsArray',\n])\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline])\n","import mixin from '../utils/mixin'\nimport Decoration from '../models/decoration'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nclass RangeInterface {\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchor === this.focus ||\n      (this.anchor.key === this.focus.key &&\n        this.anchor.offset === this.focus.offset)\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is backward.\n   *\n   * @return {Boolean}\n   */\n\n  get isBackward() {\n    const { isUnset, anchor, focus } = this\n\n    if (isUnset) {\n      return null\n    }\n\n    if (anchor.key === focus.key) {\n      return anchor.offset > focus.offset\n    }\n\n    const isBackward = PathUtils.isBefore(focus.path, anchor.path)\n    return isBackward\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    const { isBackward } = this\n    const isForward = isBackward == null ? null : !isBackward\n    return isForward\n  }\n\n  /**\n   * Check whether the range isn't set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    const { anchor, focus } = this\n    const isUnset = anchor.isUnset || focus.isUnset\n    return isUnset\n  }\n\n  /**\n   * Check whether the range is set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return !this.isUnset\n  }\n\n  /**\n   * Get the start point.\n   *\n   * @return {String}\n   */\n\n  get start() {\n    return this.isBackward ? this.focus : this.anchor\n  }\n\n  /**\n   * Get the end point.\n   *\n   * @return {String}\n   */\n\n  get end() {\n    return this.isBackward ? this.anchor : this.focus\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    const range = this.setPoints([this.focus, this.anchor])\n    return range\n  }\n\n  /**\n   * Move the anchor and focus offsets forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveForward(n) {\n    return this.updatePoints(point => point.moveForward(n))\n  }\n\n  /**\n   * Move the anchor and focus offsets backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveBackward(n) {\n    return this.updatePoints(point => point.moveBackward(n))\n  }\n\n  /**\n   * Move the anchor offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorBackward(n) {\n    const range = this.setAnchor(this.anchor.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the anchor offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorForward(n) {\n    const range = this.setAnchor(this.anchor.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(path, offset) {\n    const range = this.setAnchor(this.anchor.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the end offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndBackward(n) {\n    const range = this.setEnd(this.end.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the end offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndForward(n) {\n    const range = this.setEnd(this.end.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's end point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveEndTo(path, offset) {\n    const range = this.setEnd(this.end.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToStartOfNode(node) {\n    const range = this.setEnd(this.end.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToEndOfNode(node) {\n    const range = this.setEnd(this.end.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the focus offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusBackward(n) {\n    const range = this.setFocus(this.focus.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the focus offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusForward(n) {\n    const range = this.setFocus(this.focus.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(path, offset) {\n    const range = this.setFocus(this.focus.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOfNode(node) {\n    const range = this.setFocus(this.focus.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOfNode(node) {\n    const range = this.setFocus(this.focus.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the start offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartBackward(n) {\n    const range = this.setStart(this.start.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the start offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartForward(n) {\n    const range = this.setStart(this.start.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's start point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveStartTo(path, offset) {\n    const range = this.setStart(this.start.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToStartOfNode(node) {\n    const range = this.setStart(this.start.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToEndOfNode(node) {\n    const range = this.setStart(this.start.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move range's points to a new `path` and `offset`.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveTo(path, offset) {\n    return this.updatePoints(point => point.moveTo(path, offset))\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    const range = this.setFocus(this.anchor)\n    return range\n  }\n\n  /**\n   * Move the start point to the end point.\n   *\n   * @return {Range}\n   */\n\n  moveToEnd() {\n    const range = this.setStart(this.end)\n    return range\n  }\n\n  /**\n   * Move the range's points to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToEndOfNode(node) {\n    return this.updatePoints(point => point.moveToEndOfNode(node))\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    const range = this.setAnchor(this.focus)\n    return range\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOfNode(start, end = start) {\n    const range = this.setPoints([\n      this.anchor.moveToStartOfNode(start),\n      this.focus.moveToEndOfNode(end),\n    ])\n\n    return range\n  }\n\n  /**\n   * Move the end point to the start point.\n   *\n   * @return {Range}\n   */\n\n  moveToStart() {\n    const range = this.setEnd(this.start)\n    return range\n  }\n\n  /**\n   * Move the range's points to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToStartOfNode(node) {\n    return this.updatePoints(point => point.moveToStartOfNode(node))\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    return this.updatePoints(point => point.normalize(node))\n  }\n\n  /**\n   * Set the anchor point to a new `anchor`.\n   *\n   * @param {Point} anchor\n   * @return {Range}\n   */\n\n  setAnchor(anchor) {\n    const range = this.set('anchor', anchor)\n    return range\n  }\n\n  /**\n   * Set the end point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setEnd(point) {\n    const range = this.isBackward ? this.setAnchor(point) : this.setFocus(point)\n    return range\n  }\n\n  /**\n   * Set the focus point to a new `focus`.\n   *\n   * @param {Point} focus\n   * @return {Range}\n   */\n\n  setFocus(focus) {\n    const range = this.set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points to new `values`.\n   *\n   * @param {Array<Point>} values\n   * @return {Range}\n   */\n\n  setPoints(values) {\n    const [anchor, focus] = values\n    const range = this.set('anchor', anchor).set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points with `updater` callback\n   *\n   * @param {Function} updater\n   * @return {Range}\n   */\n\n  updatePoints(updater) {\n    let { anchor, focus } = this\n    anchor = updater(anchor)\n    focus = updater(focus)\n    return this.merge({ anchor, focus })\n  }\n\n  /**\n   * Set the start point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setStart(point) {\n    const range = this.isBackward ? this.setFocus(point) : this.setAnchor(point)\n    return range\n  }\n\n  /**\n   * Set new `properties` on the range.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Range.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const range = this.merge(props)\n    return range\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n\n  /**\n   * Return a `Range` instance from any range-like instance.\n   *\n   * @return {Range}\n   */\n\n  toRange() {\n    const properties = Range.createProperties(this)\n    const range = Range.create(properties)\n    return range\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  unset() {\n    const range = this.updatePoints(p => p.unset())\n    return range\n  }\n}\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Decoration, Range, Selection])\n","import './interfaces/object'\nimport './interfaces/model'\nimport './interfaces/node'\nimport './interfaces/element'\nimport './interfaces/range'\n\nimport Block from './models/block'\nimport Change from './models/change'\nimport Data from './models/data'\nimport Decoration from './models/decoration'\nimport Document from './models/document'\nimport Editor from './controllers/editor'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport PathUtils from './utils/path-utils'\nimport Point from './models/point'\nimport Range from './models/range'\nimport Selection from './models/selection'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"],"names":["n","generate","create","key","Error","setGenerator","func","resetGenerator","Data","attrs","Map","isMap","isPlainObject","fromJSON","object","fromJS","DEFAULTS","undefined","Document","options","data","toJSON","nodes","toArray","map","preserveKeys","isDocument","List","isList","Array","isArray","KeyUtils","document","Node","createList","Record","Inline","type","isInline","elements","list","inline","any","every","item","Mark","isMark","Set","isSet","marks","props","mark","Leaf","newMark","equals","has","newMarks","withMutations","remove","add","set","union","offset","string","text","next","slice","m","isLeaf","leaves","size","invalid","result","findLast","leaf","index","firstLeaf","cache","first","unshift","endOffset","left","right","find","startOffset","length","of","take","skip","push","Text","node","createSet","decorations","decMarks","d","l","forEach","start","dec","end","hasStart","hasEnd","splitLeaves","before","bundle","middle","after","concat","x","addMark","createLeaves","properties","newProperties","merge","one","two","regenerateKey","other","isText","isNode","kind","Block","array","el","texts","isBlock","value","block","compare","path","target","min","i","pv","get","tv","crop","a","b","ca","cb","decrement","increment","getAncestors","ancestors","newValue","newPath","isAbove","p","t","isAfter","isBefore","isEqual","isOlder","pl","tl","isSibling","butLast","isYounger","lift","parent","drop","relative","max","Math","relate","av","bv","transform","operation","position","pIndex","pEqual","pYounger","pAbove","np","paths","Point","point","isUnset","is","PathUtils","range","isAfterPoint","isBeforePoint","last","getLastText","getFirstText","hasNode","moveForward","setOffset","moveBackward","moveTo","getNode","getPath","getTextAtOffset","getOffset","getClosestBlock","getNextText","isPoint","Decoration","createProperties","anchor","focus","decoration","isDecoration","Range","isRange","JSON","stringify","TYPES","isObject","Selection","isSelection","selection","isFocused","Value","insertNode","mapRanges","updatePoints","setPath","assertNode","insertText","mapPoints","newDocument","mergeNode","resolvePath","withPath","moveAnchorTo","moveFocusTo","newIndex","moveNode","removeMark","prev","getPreviousText","removeNode","moveStartTo","unset","moveEndTo","removeText","setNode","setMark","resolveDecoration","setProperties","resolveSelection","splitNode","iterator","sel","createSelection","decs","createDecoration","filter","preserveData","preserveDecorations","preserveSelection","getClosestInline","getDescendant","getNextBlock","getPreviousBlock","getNextInline","getPreviousInline","getMarksAtRange","getActiveMarksAtRange","getLeafBlocksAtRange","getFragmentAtRange","getLeafInlinesAtRange","getTextsAtRange","isValue","moveToStartOfNode","debug","Debug","applyOperation","op","Operation","setSelection","invertOperation","inverse","inversePath","transformedSibling","OPERATION_ATTRIBUTES","apply","inverted","invert","json","ATTRIBUTES","v","toJS","isOperation","Change","operations","o","isChange","change","CommandsPlugin","commands","onCommand","command","editor","args","fn","onConstruct","registerCommand","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","char","remaining","test","charAt","getCharLength","rest","charCodeAt","getCharOffset","getCharOffsetBackward","reverse","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","getWordOffsetForward","deleteExpandedAtRange","isExpanded","deleteAtRange","hasDescendant","moveToStart","normalize","Commands","addMarkAtRange","isCollapsed","withoutNormalizing","addMarkByKey","addMarksAtRange","snapshotSelection","startKey","endKey","isStartVoid","hasVoidParent","isEndVoid","startBlock","endBlock","isHanging","prevText","startVoid","getClosestVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startText","endText","startLength","endLength","ancestor","getCommonAncestor","startChild","getFurthestAncestor","endChild","startParent","getParent","startParentIndex","indexOf","endParentIndex","child","afters","startChildIndex","endChildIndex","middles","befores","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","deleteBackwardAtRange","voidParent","isAtStartOfNode","prevBlock","prevVoid","moveFocusBackward","traversed","deleteCharBackwardAtRange","TextUtils","deleteCharForwardAtRange","deleteForwardAtRange","isVoid","nextBlock","isAtEndOfNode","nextVoid","moveFocusForward","deleteLineBackwardAtRange","deleteLineForwardAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","wordOffset","insertBlockAtRange","startInline","extra","insertNodeByKey","atEnd","siblingText","splitRange","moveToEndOfNode","splitDescendantsByKey","insertFragmentAtRange","fragment","mapDescendants","isAtStart","blocks","getBlocks","firstChild","lastChild","firstBlock","lastBlock","insertionNode","findInsertionNode","hasBlockChildren","lonelyParent","getFurthest","lonelyChild","startIndex","excludingLonelyChild","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","findDescendant","inlineChild","inlineIndex","hasSingleNode","firstNode","fragmentInner","matches","documentNode","documentInner","insertInlineAtRange","assertDescendant","splitNodeByKey","insertTextAtRange","insertTextByKey","removeMarkAtRange","removeMarkByKey","setBlocksAtRange","sets","setNodeByKey","setInlinesAtRange","inlines","splitBlockAtRange","height","h","isBackward","flip","moveAnchorToStartOfNode","setFocus","resolveRange","splitInlineAtRange","Infinity","toggleMarkAtRange","exists","some","unwrapBlockAtRange","wrappers","getClosest","isSuperset","toOrderedSet","toList","children","firstMatch","lastMatch","takeUntil","firstText","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","reduce","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","endIndex","splitText","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","wrapTextAtRange","prefix","suffix","startRange","endRange","moveToEnd","addMarkByPath","addMarksByPath","splitNodeByPath","insertFragmentByPath","insertNodeByPath","insertTextByPath","updated","isAtomic","setDecorations","mergeNodeByPath","original","previous","getPreviousSibling","moveNodeByPath","newParentPath","removeMarkByPath","removeMarksByPath","removeAllMarksByPath","state","getTextsAsArray","removeNodeByPath","removeTextByPath","replaceNodeByPath","newNode","parentPath","replaceTextByPath","setMarkByPath","setNodeByPath","prevProperties","pick","Object","keys","setTextByPath","splitDescendantsByPath","textPath","textOffset","prevIndex","unwrapInlineByPath","moveToRangeOfNode","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","unwrapChildrenByPath","childIndex","childPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","COMMANDS","method","assertPath","newKey","textKey","save","tmp","undos","lastBatch","lastOperation","shouldMerge","batch","pop","takeLast","withoutSaving","redos","newData","setData","redo","omit","undo","withoutMerging","blur","select","deselect","proxy","moveAnchorBackward","pointBackward","moveAnchorWordBackward","pointWordBackward","moveAnchorForward","pointForward","moveAnchorWordForward","pointWordForward","moveAnchorToEndOfBlock","pointEdgeObject","moveAnchorToEndOfInline","moveAnchorToEndOfDocument","moveAnchorToEndOfNode","moveToAnchor","moveAnchorToEndOfNextBlock","pointEdgeSideObject","moveAnchorToEndOfNextInline","moveAnchorToEndOfNextText","moveAnchorToEndOfPreviousBlock","moveAnchorToEndOfPreviousInline","moveAnchorToEndOfPreviousText","moveAnchorToEndOfText","moveAnchorToStartOfBlock","moveAnchorToStartOfDocument","moveAnchorToStartOfInline","moveAnchorToStartOfNextBlock","moveAnchorToStartOfNextInline","moveAnchorToStartOfNextText","moveAnchorToStartOfPreviousBlock","moveAnchorToStartOfPreviousInline","moveAnchorToStartOfPreviousText","moveAnchorToStartOfText","moveWordBackward","moveFocusWordBackward","moveToFocus","moveEndBackward","moveEndWordBackward","moveEndForward","moveEndWordForward","moveEndToEndOfBlock","moveEndToEndOfDocument","moveEndToEndOfNode","moveEndToEndOfInline","moveEndToEndOfNextBlock","moveEndToEndOfNextInline","moveEndToEndOfNextText","moveEndToEndOfPreviousBlock","moveEndToEndOfPreviousInline","moveEndToEndOfPreviousText","moveEndToEndOfText","moveEndToStartOfBlock","moveEndToStartOfDocument","moveEndToStartOfNode","moveEndToStartOfInline","moveEndToStartOfNextBlock","moveEndToStartOfNextInline","moveEndToStartOfNextText","moveEndToStartOfPreviousBlock","moveEndToStartOfPreviousInline","moveEndToStartOfPreviousText","moveEndToStartOfText","moveFocusWordForward","moveFocusToEndOfBlock","moveFocusToEndOfDocument","moveFocusToEndOfNode","moveFocusToEndOfInline","moveFocusToEndOfNextBlock","moveFocusToEndOfNextInline","moveFocusToEndOfNextText","moveFocusToEndOfPreviousBlock","moveFocusToEndOfPreviousInline","moveFocusToEndOfPreviousText","moveFocusToEndOfText","moveFocusToStartOfBlock","moveFocusToStartOfDocument","moveFocusToStartOfNode","moveFocusToStartOfInline","moveFocusToStartOfNextBlock","moveFocusToStartOfNextInline","moveFocusToStartOfNextText","moveFocusToStartOfPreviousBlock","moveFocusToStartOfPreviousInline","moveFocusToStartOfPreviousText","moveFocusToStartOfText","moveWordForward","moveStartBackward","moveStartWordBackward","moveStartForward","moveStartWordForward","moveStartToEndOfBlock","moveStartToEndOfDocument","moveStartToEndOfNode","moveStartToEndOfInline","moveStartToEndOfNextBlock","moveStartToEndOfNextInline","moveStartToEndOfNextText","moveStartToEndOfPreviousBlock","moveStartToEndOfPreviousInline","moveStartToEndOfPreviousText","moveStartToEndOfText","moveStartToStartOfBlock","moveStartToStartOfDocument","moveStartToStartOfNode","moveStartToStartOfInline","moveStartToStartOfNextBlock","moveStartToStartOfNextInline","moveStartToStartOfNextText","moveStartToStartOfPreviousBlock","moveStartToStartOfPreviousInline","moveStartToStartOfPreviousText","moveStartToStartOfText","moveToEndOfBlock","moveToEndOfDocument","moveToEndOfInline","moveToEndOfNextBlock","moveToEndOfNextInline","moveToEndOfNextText","moveToEndOfPreviousBlock","moveToEndOfPreviousInline","moveToEndOfPreviousText","moveToEndOfText","moveToRangeOfDocument","moveToStartOfBlock","moveToStartOfDocument","moveToStartOfInline","moveToStartOfNextBlock","moveToStartOfNextInline","moveToStartOfNextText","moveToStartOfPreviousBlock","moveToStartOfPreviousInline","moveToStartOfPreviousText","moveToStartOfText","snapshot","k","setAnchor","setEnd","setStart","edge","toUpperCase","Edge","side","Side","getDirectionNode","isInBlock","isPreviousInVoid","isNextInVoid","pointName","QueriesPlugin","queries","query","registerQuery","onQuery","ret","SlateError","captureStackTrace","constructor","stack","SchemaPlugin","schema","rules","schemaRules","rule","r","testRules","match","normalizeNode","error","validateNode","failure","validateRules","Queries","defaultNormalize","delete","getTexts","valid","fail","validateObject","validateType","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","getMarks","def","replace","defs","count","lastCount","nextDef","shift","rewind","err","validateParent","validatePrevious","validateNext","lastMin","deleteExpanded","addMarks","deleteBackward","deleteCharBackward","deleteLineBackward","deleteWordBackward","deleteForward","deleteCharForward","deleteLineForward","deleteWordForward","insertBlock","insertFragment","lastText","lastInline","isAppending","isInserting","newTexts","includes","newText","insertInline","getInsertMarksAtRange","replaceMark","oldMark","setBlocks","setInlines","splitBlock","depth","splitInline","toggleMark","activeMarks","unwrapBlock","unwrapInline","wrapBlock","wrapInline","wrapText","isForward","CorePlugin","plugins","AtRange","ByPath","OnHistory","OnSelection","OnValue","WithIntent","Schema","isEmpty","Editor","controller","construct","onChange","readOnly","middleware","core","run","setReadOnly","setValue","newDirtyPaths","getDirtyPaths","dirty","transformed","prototype","flushing","resolve","then","flush","obj","__command","__query","table","getKeysToPathsTable","values","fns","overrides","defineProperty","nextPath","previousPath","oldAncestors","arr","newAncestors","normalizeDirtyPaths","normalizeNodeByPath","iterations","found","registerPlugin","plugin","commandsPlugin","queriesPlugin","schemaPlugin","mixin","Interface","Classes","Class","getOwnPropertyNames","name","hasOwnProperty","desc","getOwnPropertyDescriptor","TYPE","camel","ObjectInterface","bind","entries","toLowerCase","ModelInterface","ENABLED","LEAF","Symbol","STORE_KEY","UNDEFINED","NULL","UNSET","memoizeStore","WeakMap","memoize","property","noArgs","hasArgs","takesArguments","cachedValue","getIn","setIn","newChild","resetMemoization","useMemoization","enabled","NodeInterface","descendant","nested","dict","memo","c","normalizer","ElementInterface","replaceNode","resolvePoint","forEachDescendant","pathToThisNode","foundPath","forEachDescendantWithPath","findDescendantAndPath","getMarksAtPosition","toSet","startPath","endPath","getPreviousTextAndPath","getNextTextAndPath","startMarks","endMarks","intersect","current","getBlocksAsArray","isLeafBlock","getLeafBlocksAtRangeAsArray","getBlocksByTypeAsArray","closest","startAt","targetPath","targetPosition","mode","furthest","getInlinesAsArray","isLeafInline","getLeafInlinesAtRangeAsArray","getInlinesByTypeAsArray","OrderedSet","getLeafBlocksBetweenPathPositionsAsArray","childStartPath","childEndPath","getTextsAtRangeAsArray","getMarksAsArray","currentMarks","closestBlock","previousText","getOrderedMarksAtRange","getMarksByTypeAsArray","getNextDeepMatchingNodeAndPath","nextNode","getNextMatchingNodeAndPath","childMatch","assign","findFirstDescendantAndPath","sibling","getNextNode","Stack","peek","onStartEdge","onEndEdge","relativeStartPath","relativeEndPath","pushAll","getOrderedMarksBetweenPositions","getTextsBetweenPathPositionsAsArray","getPreviousDeepMatchingNodeAndPath","getRootInlinesAtRangeAsArray","getFurthestInline","previousNode","getPreviousMatchingNodeAndPath","findLastDescendantAndPath","getPreviousNode","isSelected","dir","direction","getChild","splice","toStart","toEnd","mergeText","deep","flatMap","deleteIn","getText","ASSERTS","RangeInterface","setPoints","updater"],"mappings":"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"}